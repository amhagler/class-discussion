<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discussion Tracker</title>
  <style>
    :root{
      --primary-color:#6F263D;
      --primary-color-dark:#5c1f32;
      --secondary-color:#236192;
      --secondary-color-dark:#1b4e6f;
      --text-color:#FFFFFF;

      --bg:#f4f4f9;
      --panel:#ffffffcc;
      --panel-strong:#ffffff;
      --ink:#1f2328;
      --muted:#6b7280;

      --shadow: 0 10px 30px rgba(0,0,0,.12);
      --shadow-sm: 0 6px 18px rgba(0,0,0,.10);
      --radius: 18px;

      --pill-w: 118px;
      --pill-h: 56px;
      --pill-pad: 10px;

      /* dynamic gap (JS will set this on .stage) */
      --stage-gap-base: 28px;
      --stage-gap-dynamic: 0px;

      /* notes button size */
      --aux-d: 44px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: Arial, sans-serif;
      background: radial-gradient(1200px 700px at 10% 10%, #fff, var(--bg));
      color: var(--ink);
    }

    /* Top bar */
    .topbar{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(255,255,255,.85), rgba(255,255,255,.65));
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    .topbar-inner{
      max-width: 1200px;
      margin: 0 auto;
      padding: 12px 16px;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      justify-content:space-between;
    }
    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width: 260px;
    }
    .brand h1{
      margin:0;
      font-size: 20px;
      letter-spacing:.2px;
      color: var(--primary-color);
    }
    .brand .sub{
      font-size:12px;
      color: var(--muted);
      font-weight: 300;
    }

    .controls{
      display:flex;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
      justify-content:flex-end;
    }

    .btn{
      border: none;
      background: var(--primary-color);
      color: var(--text-color);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: 0 2px 0 rgba(0,0,0,.18);
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease, opacity .2s ease;
      user-select:none;
      font-size: 14px;
      line-height: 1;
      white-space: nowrap;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,.14); background: var(--primary-color-dark); }
    .btn:active{ transform: translateY(0px); box-shadow: 0 2px 0 rgba(0,0,0,.18); }
    .btn.secondary{ background: var(--secondary-color); }
    .btn.secondary:hover{ background: var(--secondary-color-dark); }
    .btn.ghost{
      background: rgba(255,255,255,.65);
      color: var(--primary-color);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow:none;
    }
    .btn.ghost:hover{
      background: rgba(255,255,255,.9);
      box-shadow: 0 10px 24px rgba(0,0,0,.10);
      transform: translateY(-1px);
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      transform:none !important;
      box-shadow:none !important;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      height: 18px;
      padding: 0 6px;
      border-radius: 999px;
      background: rgba(255,255,255,.25);
      border: 1px solid rgba(255,255,255,.35);
      font-size: 12px;
      font-weight: 700;
      line-height: 1;
    }

    /* Main layout */
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 16px 120px;
      position: relative;
    }

    /* Title/date ABOVE circle, clearly separated */
    .title-area{
      width: 100%;
      text-align:center;
      margin: 10px 0 46px;
      padding-bottom: 10px;
    }
    #discussionTitleDisplay{
      font-size: 28px;
      color: var(--primary-color);
      margin: 0;
      font-weight: 800;
      letter-spacing:.2px;
      line-height: 1.15;
    }
    #discussionDateDisplay{
      font-size: 14px;
      margin-top: 10px;
      color: var(--muted);
      font-weight: 300;
    }

    /* Setup panels */
    .setup-card{
      width: min(820px, 96%);
      margin: 0 auto 18px;
      background: var(--panel);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      backdrop-filter: blur(12px);
      padding: 14px;
    }
    .setup-row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
    }
    label{ font-size: 13px; color: var(--muted); font-weight: 300; }
    input[type="text"]{
      padding: 12px 12px;
      font-size: 16px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.14);
      outline:none;
      width: min(520px, 92vw);
      background: rgba(255,255,255,.85);
    }
    input[type="text"]:focus{
      border-color: rgba(35,97,146,.55);
      box-shadow: 0 0 0 4px rgba(35,97,146,.10);
    }
    .tiny-note{
      font-size: 12px;
      color: var(--muted);
      font-weight: 300;
      margin-top: 8px;
      text-align:center;
    }

    /* Circle + canvas */
    .stage{
      display:flex;
      justify-content:center;
      margin-top: calc(var(--stage-gap-base) + var(--stage-gap-dynamic));
    }
    #circle{
      position: relative;
      width: 860px;
      height: 860px;
      border-radius: 50%;
      border: 2px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.78);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow: visible;
    }

    /* Heatmap canvas under connection lines, above background */
    #heatCanvas{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      border-radius: 50%;
    }
    canvas#connectionCanvas{
      position:absolute;
      inset:0;
      z-index:1;
      pointer-events:none;
    }

    /* Center overlay inside circle */
    .centerOverlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 5;
      pointer-events:none;
    }
    .centerOverlay > *{ pointer-events:auto; }

    /* Pause button centered, circular */
    .pause-center{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      z-index: 4;
      pointer-events:auto;
    }
    .pause-center.hidden{ display:none; }
    .pause-circle{
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.72);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-sm);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      user-select:none;
    }
    .pause-circle:hover{
      transform: scale(1.03);
      box-shadow: 0 14px 32px rgba(0,0,0,.16);
      background: rgba(255,255,255,.86);
    }
    .pause-icon{
      font-size: 22px;
      color: var(--primary-color);
      line-height: 1;
      font-weight: 800;
    }

    /* Participants */
    .participant{
      position:absolute;
      transform: translate(-50%, -50%);
      z-index: 10;
      text-align:center;
      width: var(--pill-w);
      --nx: 0px;   /* notes button x */
      --ny: 0px;   /* notes button y */
    }

    .pill{
      width: var(--pill-w);
      height: var(--pill-h);
      border-radius: 999px;
      padding: var(--pill-pad);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 3px;

      background: linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.10));
      border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      backdrop-filter: blur(10px);

      background-color: var(--primary-color);
      color: var(--text-color);
      transition: transform .14s ease, box-shadow .14s ease, background-color .18s ease, filter .18s ease;
      will-change: transform;
      cursor: pointer;
      user-select:none;
      position: relative;
    }

    .pill .count{
      font-size: 12px;
      font-weight: 700;
      opacity: .95;
      line-height: 1;
    }
    .pill .name{
      font-size: 16px;
      font-weight: 800;
      line-height: 1.05;
      letter-spacing:.2px;
      max-width: 100%;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      pointer-events:none;
    }

    .pill.selected{
      box-shadow:
        0 10px 22px rgba(0,0,0,.10),
        0 0 0 3px rgba(255,255,255,.55),
        0 0 0 6px rgba(35,97,146,.35);
      outline: 2px solid var(--secondary-color);
      outline-offset: 2px;
    }

    .pill.active{
      background-color: var(--secondary-color);
      filter: saturate(1.05);
      transform: translateY(-1px) scale(1.03);
      box-shadow: 0 16px 34px rgba(0,0,0,.16);
      outline: none;
    }
    .pill.pulse{ animation: microPulse .26s ease-out; }
    @keyframes microPulse{
      0%{ transform: translateY(-1px) scale(1.00); }
      60%{ transform: translateY(-2px) scale(1.05); }
      100%{ transform: translateY(-1px) scale(1.03); }
    }

    /* Notes button OUTSIDE circle (positioned by JS via --nx/--ny) */
    .notes-out{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%) translate(var(--nx), var(--ny));
      z-index: 12;
      width: var(--aux-d);
      height: var(--aux-d);
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.86);
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      backdrop-filter: blur(12px);
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
    }
    .notes-out:hover{
      transform: translate(-50%,-50%) translate(var(--nx), var(--ny)) scale(1.03);
      box-shadow: 0 16px 36px rgba(0,0,0,.16);
      background: rgba(255,255,255,.94);
    }
    .notes-out:active{
      transform: translate(-50%,-50%) translate(var(--nx), var(--ny)) scale(1.00);
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
    }
    .notes-out .icon{
      font-size: 18px;
      line-height: 1;
      color: rgba(31,35,40,.90);
      transform: translateY(-.5px);
    }

    /* Hotkey indicator INSIDE the notes button */
    .notes-out .hk{
      position:absolute;
      right: -6px;
      top: -6px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 11px;
      font-weight: 900;
      color: rgba(31,35,40,.92);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 18px rgba(0,0,0,.12);
      pointer-events:none;
    }

    /* Rating box centered INSIDE circle */
    .modal-card{
      width: min(460px, 88vw);
      background: rgba(255,255,255,.86);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 14px;
    }
    .modal-card h2{
      margin: 0 0 10px;
      color: var(--primary-color);
      font-size: 18px;
    }
    .rating-options{
      display:flex;
      gap:10px;
      justify-content:center;
      margin: 10px 0 12px;
    }
    .rating-option{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.10);
      transition: transform .12s ease, background .2s ease;
      user-select:none;
      font-weight: 800;
      color: var(--ink);
    }
    .rating-option:hover{ transform: translateY(-1px); background: rgba(0,0,0,.12); }
    .rating-option.selected{
      background: var(--primary-color);
      color: var(--text-color);
      border-color: rgba(0,0,0,.0);
    }

   /* Tag chips (rating modal only) */
.tag-row{
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
  margin: 10px auto 8px;
  width: min(420px, 100%);
  justify-content: center;
  align-items: stretch;
}

/* compact, regular chips */
.chip{
  position: relative;
  width: 100%;
  text-align: left;

  border: 1px solid rgba(0,0,0,.10);
  background: rgba(0,0,0,.035);
  color: var(--ink);

  border-radius: 14px;
  padding: 8px 12px;

  font-size: 12px;
  font-weight: 800;
  cursor:pointer;
  user-select:none;

  transition: transform .10s ease, background .18s ease, border-color .18s ease;
  box-shadow: none;
  line-height: 1.1;
}

.chip:hover{
  transform: translateY(-1px);
  background: rgba(35,97,146,.08);
  border-color: rgba(35,97,146,.22);
}

.chip.active{
  background: rgba(35,97,146,.14);
  border-color: rgba(35,97,146,.30);
}

/* hotkey badge: single letter, compact, consistent */
.chip .hk{
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 22px;
  height: 22px;
  border-radius: 999px;

  display:flex;
  align-items:center;
  justify-content:center;

  font-size: 11px;
  font-weight: 900;
  letter-spacing: .02em;

  color: rgba(31,35,40,.90);
  background: rgba(255,255,255,.85);
  border: 1px solid rgba(0,0,0,.10);
}

/* subtle responsiveness */
@media (max-width: 520px){
  .tag-row{ grid-template-columns: 1fr; width: 100%; }
}
    textarea{
      width: 100%;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.14);
      padding: 10px 12px;
      font-size: 14px;
      outline:none;
      background: rgba(255,255,255,.90);
      resize: vertical;
    }
    textarea:focus{
      border-color: rgba(35,97,146,.55);
      box-shadow: 0 0 0 4px rgba(35,97,146,.10);
    }

    /* Overlays */
    #colorSchemePopup,
    #customColorPopup,
    #confirmRestartPopup,
    #editParticipantsPopup,
    #notesBox{
      display:none;
      position:fixed;
      inset:0;
      z-index: 200;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .popup{
      width: min(920px, 94vw);
      max-height: 86vh;
      overflow:auto;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .popup h2{
      margin: 0 0 10px;
      color: var(--primary-color);
      font-size: 18px;
    }

    #colorSchemeList{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:10px;
      padding:0;
      margin:0;
      list-style:none;
    }

    /* Replay Dock (side, attractive) */
    #replayDock{
      display:none;
      position: fixed;
      right: 18px;
      top: 124px;
      z-index: 120;
      width: 260px;
      border-radius: 20px;
      background: rgba(255,255,255,.88);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 16px 44px rgba(0,0,0,.18);
      padding: 12px;
    }
    #replayDock .dock-title{
      margin: 0 0 8px;
      font-size: 14px;
      font-weight: 800;
      color: var(--primary-color);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    #replayDock .dock-sub{
      margin: 10px 0 8px;
      font-size: 12px;
      font-weight: 300;
      color: var(--muted);
    }
    #replayDock .dock-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    #replayDock .dock-btn{
      flex: 1 1 30%;
      justify-content:center;
      padding: 10px 10px;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(0,0,0,.04);
      color: var(--ink);
      font-weight: 800;
      cursor:pointer;
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      box-shadow: 0 2px 0 rgba(0,0,0,.10);
    }
    #replayDock .dock-btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(0,0,0,.14);
      background: rgba(35,97,146,.10);
    }
    #replayDock .dock-btn.primaryish{ background: rgba(111,38,61,.08); }
    #replayDock .dock-btn.primaryish:hover{ background: rgba(111,38,61,.14); }

    .heat-toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      font-weight: 800;
      color: var(--muted);
      user-select:none;
    }
    .heat-dot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 6px 14px rgba(0,0,0,.12);
    }

    @media (max-width: 1100px){
      #replayDock{
        right: 12px;
        top: auto;
        bottom: 12px;
        width: min(520px, calc(100vw - 24px));
      }
    }
    @media (max-width: 900px){
      #circle{ width: 92vw; height: 92vw; max-width: 860px; max-height: 860px; }
      #colorSchemeList{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      :root{ --pill-w: 112px; --pill-h: 54px; --aux-d: 42px; }
    }

    .scheme{
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 16px;
      background: rgba(255,255,255,.70);
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .swatches{ display:flex; gap:10px; align-items:center; justify-content:flex-start; }
    .swatch{
      width: 30px; height: 30px; border-radius: 50%;
      border: 1px solid rgba(0,0,0,.10);
    }
    .scheme .team-name{ font-size: 13px; color: var(--ink); font-weight: 800; }
    .scheme .select-button{
      width: 100%;
      border:none;
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      background: var(--primary-color);
      color: var(--text-color);
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      box-shadow: 0 2px 0 rgba(0,0,0,.14);
    }
    .scheme .select-button:hover{
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0,0,0,.14);
      background: var(--primary-color-dark);
    }

    /* Bottom drawer */
    .drawer-backdrop{
      position: fixed;
      inset:0;
      z-index: 140;
      background: rgba(0,0,0,.22);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
    }
    .drawer-backdrop.open{ opacity: 1; pointer-events: auto; }

    .drawer{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 0;
      z-index: 150;
      width: min(1200px, 100%);
      border-radius: 22px 22px 0 0;
      background: rgba(255,255,255,.90);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 -14px 40px rgba(0,0,0,.18);
      max-height: 78vh;
      height: 48vh;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      translate: 0 105%;
      transition: translate .22s ease;
    }
    .drawer.open{ translate: 0 0; }

    .drawer-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    .handle{
      width: 44px;
      height: 5px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      margin: 0 auto;
    }
    .tabs{ display:flex; align-items:center; gap:8px; }
    .tab{
      border:none;
      cursor:pointer;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.06);
      color: var(--ink);
      font-weight: 800;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: transform .12s ease, background .2s ease;
    }
    .tab:hover{ transform: translateY(-1px); background: rgba(0,0,0,.10); }
    .tab.active{ background: var(--secondary-color); color: var(--text-color); }

    .drawer-actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .drawer-body{ padding: 10px 12px 12px; overflow:auto; }

    table{
      width: 100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.95);
    }
    thead th{
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, var(--primary-color), var(--primary-color-dark));
      color: var(--text-color);
      font-weight: 800;
      font-size: 13px;
      text-align:left;
      padding: 10px;
      z-index: 1;
    }
    tbody td{
      padding: 10px;
      border-top: 1px solid rgba(0,0,0,.08);
      font-size: 13px;
      vertical-align: top;
      white-space: pre-wrap;
    }
    tbody tr:nth-child(even) td{ background: rgba(0,0,0,.03); }

    .cell-editable{
      cursor: text;
      border-radius: 10px;
      transition: background .14s ease;
    }
    .cell-editable:hover{
      background: rgba(35,97,146,.08);
    }
    .cell-input,
    .cell-select{
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,.14);
      padding: 8px 10px;
      font-size: 13px;
      background: rgba(255,255,255,.96);
      outline: none;
    }
    .cell-input:focus,
    .cell-select:focus{
      border-color: rgba(35,97,146,.55);
      box-shadow: 0 0 0 4px rgba(35,97,146,.10);
    }

    .section-title{
      margin: 10px 0 8px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 300;
    }

    .mini-popup{
      width: min(520px, 94vw);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 14px;
      position: relative;
    }
    .mini-popup h2{ margin:0 0 10px; color: var(--primary-color); font-size:18px; }
    .mini-actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    .close-x{
      position:absolute;
      top: 16px;
      right: 18px;
      background: transparent;
      border: none;
      cursor:pointer;
      font-size: 22px;
      color: rgba(0,0,0,.55);
    }

    @media print{
      .topbar,
      #replayDock,
      #drawerBackdrop,
      #drawer,
      #discussionDetails,
      #participantFormWrap,
      #colorSchemePopup,
      #customColorPopup,
      #confirmRestartPopup,
      #editParticipantsPopup,
      #notesBox{
        display:none !important;
      }
      body{ background: #fff !important; }
      .wrap{ padding: 12px 12px 12px !important; }
      #circle{
        box-shadow:none !important;
        border: 1px solid rgba(0,0,0,.25) !important;
        background:#fff !important;
      }
      .title-area{ margin: 0 0 12px !important; padding-bottom: 0 !important; }
      .notes-out{ display:none !important; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <h1>Discussion Tracker</h1>
        <div class="sub">live facilitation + post-discussion analysis</div>
      </div>

      <div class="controls">
        <button id="endDiscussionButton" class="btn secondary" style="display:none;" onclick="endDiscussion()">
          ‚èπ End
        </button>

        <button id="toggleDrawerButton" class="btn ghost" onclick="toggleDrawer()">
          ‚ò∞ Open Panel
        </button>

        <button id="copyBothButton" class="btn" style="display:none;" onclick="copyBoth()">
          ‚ßâ Copy Both
        </button>

        <button id="restartDiscussionButton" class="btn" style="display:none;" onclick="confirmRestartDiscussion()">
          ‚Üª Restart
        </button>

        <button id="generateReportButton" class="btn secondary" style="display:none;" onclick="generateReport()">
          ‚ú® Generate Report
        </button>

        <button id="colorSchemeButton" class="btn ghost" onclick="openColorSchemePopup()">
          üé® Colors
        </button>

        <button id="editParticipantsButton" class="btn ghost" style="display:none;" onclick="openEditParticipantsPopup()">
          üë• Participants
        </button>

        <button id="exportScreenshotButton" class="btn ghost" style="display:none;" onclick="exportScreenshot()">
          üì∑ Screenshot / Print
        </button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="title-area" id="titleArea">
      <div id="discussionTitleDisplay"></div>
      <div id="discussionDateDisplay"></div>
    </div>

    <div id="discussionDetails" class="setup-card">
      <div class="setup-row">
        <label for="discussionTitle">Discussion Title:</label>
        <input type="text" id="discussionTitle" placeholder="e.g., Arab Spring Seminar (B Block)" required />
        <button class="btn secondary" onclick="startDiscussion()">‚ñ∂ Start</button>
      </div>
      <div class="tiny-note">
        Tip: Enter starts. Later, click a pill to record speaking.
      </div>
    </div>

    <div id="participantFormWrap" class="setup-card" style="display:none;">
      <form id="participantForm">
        <div class="setup-row">
          <label for="name">Participant Name:</label>
          <input type="text" id="name" placeholder="Add a student..." required />
          <button class="btn" type="submit">Ôºã Add</button>
          <button class="btn secondary" type="button" onclick="doneAddingParticipants()">‚úì Done</button>
        </div>
      </form>
      <div class="tiny-note">
        Duplicate names will prompt: ‚ÄúAlready exists. Add anyway?‚Äù (You can still force it.)
      </div>
    </div>

    <div class="stage" id="stage">
      <div id="circle">
        <canvas id="heatCanvas" width="860" height="860"></canvas>
        <canvas id="connectionCanvas" width="860" height="860"></canvas>

        <div id="pauseCenter" class="pause-center">
          <button class="pause-circle" title="Pause (ends current speaking segment)" onclick="pauseTimer()">
            <span class="pause-icon">‚è∏</span>
          </button>
        </div>

        <div class="centerOverlay">
          <div id="ratingBox" class="modal-card" style="display:none;">
            <h2>Rate Contribution</h2>

            <div class="rating-options">
              <div class="rating-option" onclick="selectRating(1)">1</div>
              <div class="rating-option" onclick="selectRating(2)">2</div>
              <div class="rating-option" onclick="selectRating(3)">3</div>
              <div class="rating-option" onclick="selectRating(4)">4</div>
              <div class="rating-option" onclick="selectRating(5)">5</div>
            </div>

            <div class="tag-row" id="tagRow"></div>

            <label for="comment">Comment:</label>
            <textarea id="comment" rows="3" placeholder="Optional quick note..."></textarea>

            <div style="display:flex;justify-content:flex-end;margin-top:10px;">
              <button class="btn secondary" onclick="startTimer()">‚úÖ Save</button>
            </div>

            <div style="margin-top:8px;color:var(--muted);font-size:12px;font-weight:300;">
              Tip: Ctrl+Enter saves. Keys 1‚Äì5 select rating. Alt+E/B/Q/D/O/R/T toggle tags. Participant hotkeys work only when this box is closed.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="replayDock" aria-hidden="true">
      <div class="dock-title">
        <span>Replay</span>
        <span class="heat-toggle" id="heatStatus">
          <span class="heat-dot"></span>
          <span id="heatStatusText">Heatmap: off</span>
        </span>
      </div>

      <div class="dock-sub">Order Replay</div>
      <div class="dock-row">
        <button class="dock-btn" onclick="replayDiscussion(2)">2√ó</button>
        <button class="dock-btn" onclick="replayDiscussion(4)">4√ó</button>
        <button class="dock-btn" onclick="replayDiscussion(8)">8√ó</button>
      </div>

      <div class="dock-sub">Timed Replay</div>
      <div class="dock-row">
        <button class="dock-btn" onclick="replayDiscussionTimed(8)">8√ó</button>
        <button class="dock-btn" onclick="replayDiscussionTimed(16)">16√ó</button>
        <button class="dock-btn" onclick="replayDiscussionTimed(32)">32√ó</button>
      </div>

      <div class="dock-sub">Heatmap</div>
      <div class="dock-row">
        <button class="dock-btn primaryish" onclick="showHeatmap()">Show</button>
        <button class="dock-btn" onclick="hideHeatmap()">Hide</button>
      </div>
    </div>
  </div>

  <!-- Drawer -->
  <div id="drawerBackdrop" class="drawer-backdrop" onclick="closeDrawer()"></div>

  <div id="drawer" class="drawer" aria-hidden="true">
    <div class="drawer-header">
      <div style="display:flex;flex-direction:column;gap:6px;min-width: 180px;">
        <div class="handle"></div>
        <div class="tabs">
          <button id="tabLog" class="tab active" onclick="switchTab('log')">
            Log <span id="logCount" class="badge">0</span>
          </button>
          <button id="tabReport" class="tab" onclick="switchTab('report')" disabled>
            Report <span id="reportReady" class="badge">‚Äî</span>
          </button>
        </div>
      </div>

      <div class="drawer-actions">
        <button id="copyLogButton" class="btn" style="display:none;" onclick="copyLog()">‚ßâ Copy Log</button>
        <button id="copyReportButton" class="btn" style="display:none;" onclick="copyReport()">‚ßâ Copy Report</button>
        <button id="drawerCloseButton" class="btn ghost" onclick="closeDrawer()">‚úï Close</button>
      </div>
    </div>

    <div class="drawer-body">
      <div id="logPanel">
        <div class="section-title">Discussion Log (click Rating or Comment to edit inline)</div>
        <table id="logTable">
          <thead>
            <tr>
              <th>Participant</th>
              <th>Timestamp</th>
              <th>Rating</th>
              <th>Comment</th>
              <th>Duration</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div id="reportPanel" style="display:none;">
        <div class="section-title">Report</div>
        <table id="reportTable">
          <thead>
            <tr>
              <th>Participant</th>
              <th>All Ratings</th>
              <th>Average</th>
              <th>Total Air Time</th>
              <th>Domination</th>
              <th>Tag Counts</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>

        <div class="section-title">Notes</div>
        <table id="notesReportTable">
          <thead>
            <tr>
              <th>Participant</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Notes popup -->
  <div id="notesBox">
    <div class="mini-popup" role="dialog" aria-modal="true">
      <h2 id="notesBoxTitle">Notes</h2>
      <textarea id="notesText" rows="5" placeholder="Quick notes..."></textarea>
      <div class="mini-actions">
        <button class="btn secondary" onclick="saveNotes()">‚úÖ Save</button>
        <button class="btn ghost" onclick="closeNotesBox()">‚úï Cancel</button>
      </div>
      <div class="tiny-note" style="text-align:left;margin-top:10px;">
        Notes are timestamped like <strong>10:14</strong>: ‚Äúkept returning to evidence‚Äù.
      </div>
    </div>
  </div>

  <!-- Color Scheme popup -->
  <div id="colorSchemePopup">
    <div class="popup">
      <h2>Color Scheme</h2>
      <ul id="colorSchemeList"></ul>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;align-items:center;">
        <label style="display:flex;align-items:center;gap:10px;">
          <input id="enableHtml2canvas" type="checkbox" />
          Enable Screenshot Capture (loads html2canvas)
        </label>
        <button class="btn ghost" onclick="closeColorSchemePopup()">‚úï Close</button>
      </div>
      <div class="tiny-note" style="text-align:left;">
        If screenshot capture is off/unavailable, Screenshot will fall back to a clean Print-to-PDF view.
      </div>
    </div>
  </div>

  <div id="customColorPopup">
    <div class="mini-popup">
      <h2>Select Your Own Colors</h2>
      <label for="primaryColor">Primary Color:</label>
      <input type="color" id="primaryColor" oninput="updatePrimaryColorCode()" style="width:100%;height:54px;border:none;background:transparent;"/>
      <div id="primaryColorCode" style="margin:8px 0;color:var(--muted);font-weight:300;">#000000</div>
      <label for="secondaryColor">Secondary Color:</label>
      <input type="color" id="secondaryColor" oninput="updateSecondaryColorCode()" style="width:100%;height:54px;border:none;background:transparent;"/>
      <div id="secondaryColorCode" style="margin:8px 0;color:var(--muted);font-weight:300;">#000000</div>
      <div class="mini-actions">
        <button class="btn secondary" onclick="applyCustomColors()">‚úÖ Apply</button>
        <button class="btn ghost" onclick="closeCustomColorPopup()">‚úï Cancel</button>
      </div>
    </div>
  </div>

  <div id="confirmRestartPopup">
    <div class="mini-popup">
      <h2>Confirmation</h2>
      <p style="margin:8px 0;color:var(--muted);font-weight:300;">This will erase all data! Are you sure you wish to proceed?</p>
      <div class="mini-actions">
        <button class="btn secondary" onclick="restartDiscussion()">Yes. I have saved my data.</button>
        <button class="btn ghost" onclick="closeConfirmRestartPopup()">No. Let me go back.</button>
      </div>
    </div>
  </div>

  <div id="editParticipantsPopup">
    <div class="popup" style="position:relative;">
      <button class="close-x" onclick="closeEditParticipantsPopup()">‚úï</button>
      <h2>Edit Participants</h2>
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <input type="text" id="newParticipantName" placeholder="Participant Name" />
        <button class="btn" onclick="addNewParticipant()">Ôºã Add</button>
        <button class="btn ghost" onclick="openReorderParticipants()">‚Üï Reorder</button>
        <button class="btn ghost" onclick="openRenameParticipants()">‚úé Rename</button>
      </div>

      <div id="reorderParticipantsContainer" style="display:none;margin-top:14px;">
        <div class="section-title">Drag to reorder</div>
        <ul id="reorderParticipantsList" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px;"></ul>
        <div style="display:flex;justify-content:flex-end;margin-top:10px;">
          <button class="btn secondary" onclick="saveReorderedParticipants()">‚úÖ Save Order</button>
        </div>
      </div>

      <div id="renameParticipantsContainer" style="display:none;margin-top:14px;">
        <div class="section-title">Rename</div>
        <ul id="renameParticipantsList" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px;"></ul>
        <div style="display:flex;justify-content:flex-end;margin-top:10px;">
          <button class="btn secondary" onclick="saveRenamedParticipants()">‚úÖ Done</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- DOM ----------
    const participantFormWrap = document.getElementById('participantFormWrap');
    const participantForm = document.getElementById('participantForm');
    const circle = document.getElementById('circle');
    const stage = document.getElementById('stage');

    const heatCanvas = document.getElementById('heatCanvas');
    const heatCtx = heatCanvas.getContext('2d');

    const canvas = document.getElementById('connectionCanvas');
    const ctx = canvas.getContext('2d');

    const ratingBox = document.getElementById('ratingBox');
    const pauseCenter = document.getElementById('pauseCenter');
    const replayDock = document.getElementById('replayDock');

    const logTableBody = document.querySelector('#logTable tbody');
    const reportTableBody = document.querySelector('#reportTable tbody');
    const notesReportTableBody = document.querySelector('#notesReportTable tbody');

    const discussionTitleDisplay = document.getElementById('discussionTitleDisplay');
    const discussionDateDisplay = document.getElementById('discussionDateDisplay');

    // ‚ÄúNow speaking‚Äù removed ‚Äî keep these null-safe
    const nowSpeaking = null;
    const nowSpeakingName = null;

    const heatStatusText = document.getElementById('heatStatusText');

    // Drawer
    const drawer = document.getElementById('drawer');
    const drawerBackdrop = document.getElementById('drawerBackdrop');
    const tabLog = document.getElementById('tabLog');
    const tabReport = document.getElementById('tabReport');
    const logPanel = document.getElementById('logPanel');
    const reportPanel = document.getElementById('reportPanel');
    const logCount = document.getElementById('logCount');
    const reportReady = document.getElementById('reportReady');

    // Buttons
    const endDiscussionButton = document.getElementById('endDiscussionButton');
    const editParticipantsButton = document.getElementById('editParticipantsButton');
    const copyLogButton = document.getElementById('copyLogButton');
    const copyReportButton = document.getElementById('copyReportButton');
    const copyBothButton = document.getElementById('copyBothButton');
    const restartDiscussionButton = document.getElementById('restartDiscussionButton');
    const generateReportButton = document.getElementById('generateReportButton');
    const exportScreenshotButton = document.getElementById('exportScreenshotButton');

    // Notes popup
    const notesOverlay = document.getElementById('notesBox');
    const notesText = document.getElementById('notesText');
    const notesBoxTitle = document.getElementById('notesBoxTitle');

    // Color scheme popup
    const colorSchemePopup = document.getElementById('colorSchemePopup');
    const colorSchemeList = document.getElementById('colorSchemeList');
    const customColorPopup = document.getElementById('customColorPopup');
    const primaryColorInput = document.getElementById('primaryColor');
    const secondaryColorInput = document.getElementById('secondaryColor');
    const primaryColorCode = document.getElementById('primaryColorCode');
    const secondaryColorCode = document.getElementById('secondaryColorCode');
    const enableHtml2canvas = document.getElementById('enableHtml2canvas');

    // Restart popup
    const confirmRestartPopup = document.getElementById('confirmRestartPopup');

    // Edit participants popup
    const editParticipantsPopup = document.getElementById('editParticipantsPopup');
    const reorderParticipantsContainer = document.getElementById('reorderParticipantsContainer');
    const reorderParticipantsList = document.getElementById('reorderParticipantsList');
    const renameParticipantsContainer = document.getElementById('renameParticipantsContainer');
    const renameParticipantsList = document.getElementById('renameParticipantsList');

    // Tags (rating modal)
    const tagRow = document.getElementById('tagRow');

    // ---------- STATE ----------
    let participants = [];
    let connections = [];
    const connectionCounts = {};
    let lastSpokenId = null;
    let currentSpeakerId = null;
    let selectedRating = null;
    let currentNotesParticipantId = null;
    let teamName = null;

    // keyboard selection state
    let selectedParticipantId = null;
    let discussionEnded = false;

    // geometry
    let circleDiameter = 860;
    let circleRadius = circleDiameter / 2;
    let centerX = circleRadius;
    let centerY = circleRadius;

    // heatmap state
    let heatmapActive = false;

    // ‚úÖ tag config + hotkeys (generic)
// Hotkeys supported:
// - Option/Alt + Letter (Mac Option works as altKey in JS)
// - Command + Shift + Letter (additional, does NOT replace Alt/Option)
//
// Keep letters chosen to avoid collisions with participant layer as much as possible.
const TAGS = [
  { key:'Evidence',          label:'‚úÖ Evidence',                 hk:'‚å•E / ‚åò‚áßE', letter:'E', group:'good' },
  { key:'BuildsOnOthers',    label:'‚úÖ Builds on others',         hk:'‚å•B / ‚åò‚áßB', letter:'B', group:'good' },
  { key:'AsksQuestion',      label:'‚úÖ Asks question',            hk:'‚å•U / ‚åò‚áßU', letter:'U', group:'good' },

  { key:'Clarifies',         label:'‚úÖ Clarifies / summarizes',   hk:'‚å•S / ‚åò‚áßS', letter:'S', group:'good' },
  { key:'ConnectsTexts',     label:'‚úÖ Connects across texts',    hk:'‚å•X / ‚åò‚áßX', letter:'X', group:'good' },
  { key:'WrongButBold',      label:'üü° Wrong but bold',           hk:'‚å•W / ‚åò‚áßW', letter:'W', group:'good' },

  { key:'Dominates',         label:'‚ö†Ô∏è Dominates',                hk:'‚å•D / ‚åò‚áßD', letter:'D', group:'warn' },
  { key:'OffTopic',          label:'‚ö†Ô∏è Off-topic',                hk:'‚å•O / ‚åò‚áßO', letter:'O', group:'warn' },
  { key:'Repeats',           label:'‚ö†Ô∏è Repeats point',            hk:'‚å•R / ‚åò‚áßR', letter:'R', group:'warn' },

  { key:'GreatInsight',      label:'üåü Great insight',            hk:'‚å•I / ‚åò‚áßI', letter:'I', group:'star' },
];

// Map letter -> tag key for hotkey handling
const TAG_HOTKEYS = new Map(TAGS.map(t => [t.letter.toUpperCase(), t.key]));

let selectedTagsForEntry = new Set(); // keys for current rating entry
    function clipToCircle(context){
      context.save();
      context.beginPath();
      context.arc(centerX, centerY, circleRadius - 2, 0, Math.PI*2);
      context.clip();
    }
    function unclip(context){ context.restore(); }

    function escapeHtml(str){
      return String(str).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }

    function uuid(){
      if (crypto && crypto.randomUUID) return crypto.randomUUID();
      return 'p_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
    }

    function getParticipantById(id){ return participants.find(p => p.id === id) || null; }
    function idxById(id){ return participants.findIndex(p => p.id === id); }

    // ---------- TEAMS ----------
    const nhlTeams = [
      { name: 'Anaheim Ducks', colors: ['#F47A38', '#B09862'] },
      { name: 'Boston Bruins', colors: ['#000000', '#FFB81C'] },
      { name: 'Buffalo Sabres', colors: ['#002654', '#FCB514'] },
      { name: 'Calgary Flames', colors: ['#C8102E', '#F1BE48'] },
      { name: 'Carolina Hurricanes', colors: ['#CC0000', '#A2AAAD'] },
      { name: 'Chicago Blackhawks', colors: ['#CF0A2C', '#000000'] },
      { name: 'Colorado Avalanche', colors: ['#6F263D', '#236192'] },
      { name: 'Columbus Blue Jackets', colors: ['#002654', '#CE1126'] },
      { name: 'Dallas Stars', colors: ['#006847', '#8F8F8C'] },
      { name: 'Detroit Red Wings', colors: ['#CE1126', '#FFFFFF'] },
      { name: 'Edmonton Oilers', colors: ['#041E42', '#FF4C00'] },
      { name: 'Florida Panthers', colors: ['#041E42', '#C8102E'] },
      { name: 'Los Angeles Kings', colors: ['#111111', '#A2AAAD'] },
      { name: 'Minnesota Wild', colors: ['#154734', '#A6192E'] },
      { name: 'Montreal Canadiens', colors: ['#AF1E2D', '#192168'] },
      { name: 'Nashville Predators', colors: ['#FFB81C', '#041E42'] },
      { name: 'New Jersey Devils', colors: ['#CE1126', '#000000'] },
      { name: 'New York Islanders', colors: ['#00539B', '#F47D30'] },
      { name: 'New York Rangers', colors: ['#0038A8', '#CE1126'] },
      { name: 'Ottawa Senators', colors: ['#E31837', '#C69214'] },
      { name: 'Philadelphia Flyers', colors: ['#F74902', '#000000'] },
      { name: 'Pittsburgh Penguins', colors: ['#FFB81C', '#000000'] },
      { name: 'San Jose Sharks', colors: ['#006D75', '#EA7200'] },
      { name: 'Seattle Kraken', colors: ['#001628', '#99D9D9'] },
      { name: 'St. Louis Blues', colors: ['#002F87', '#FDB827'] },
      { name: 'Tampa Bay Lightning', colors: ['#002868', '#767676'] },
      { name: 'Toronto Maple Leafs', colors: ['#00205B', '#767676'] },
      { name: 'Utah Mammoth', colors: ['#111827', '#A855F7'] },
      { name: 'Vancouver Canucks', colors: ['#001F5B', '#00843D'] },
      { name: 'Vegas Golden Knights', colors: ['#B4975A', '#333F42'] },
      { name: 'Washington Capitals', colors: ['#041E42', '#C8102E'] },
      { name: 'Winnipeg Jets', colors: ['#041E42', '#AC162C'] },
      { name: 'UCLA (Blue & Gold)', colors: ['#2774AE', '#FFD100'] }
    ];

    // ---------- COLOR SCHEME ----------
    function darkenColor(hex){
      const amount = 0.2;
      const clean = String(hex).replace('#','').trim();
      const r = parseInt(clean.slice(0,2),16);
      const g = parseInt(clean.slice(2,4),16);
      const b = parseInt(clean.slice(4,6),16);
      const rr = Math.floor(r*(1-amount)).toString(16).padStart(2,'0');
      const gg = Math.floor(g*(1-amount)).toString(16).padStart(2,'0');
      const bb = Math.floor(b*(1-amount)).toString(16).padStart(2,'0');
      return `#${rr}${gg}${bb}`;
    }

    function isWhiteish(hex){
      const v = hex.trim().toUpperCase();
      return v === '#FFFFFF' || v === '#FFF' || v === '#FFD100';
    }
    function isBlackish(hex){
      const v = hex.trim().toUpperCase();
      return v === '#000000' || v === '#000';
    }

    function updateColorScheme(primary, secondary, team){
      document.documentElement.style.setProperty('--primary-color', primary);
      document.documentElement.style.setProperty('--primary-color-dark', darkenColor(primary));
      document.documentElement.style.setProperty('--secondary-color', secondary);
      document.documentElement.style.setProperty('--secondary-color-dark', darkenColor(secondary));
      teamName = team;

      if (secondary.toUpperCase() === '#FFFFFF' || secondary.toUpperCase() === '#FFD100') {
        document.documentElement.style.setProperty('--text-color', '#000000');
      } else {
        document.documentElement.style.setProperty('--text-color', '#FFFFFF');
      }

      if (heatmapActive){
        showHeatmap();
      }
      redrawConnections();
    }

    function openColorSchemePopup(){ colorSchemePopup.style.display='flex'; }
    function closeColorSchemePopup(){ colorSchemePopup.style.display='none'; }
    function openCustomColorPopup(){ customColorPopup.style.display='flex'; }
    function closeCustomColorPopup(){ customColorPopup.style.display='none'; }
    function updatePrimaryColorCode(){ primaryColorCode.textContent = primaryColorInput.value; }
    function updateSecondaryColorCode(){ secondaryColorCode.textContent = secondaryColorInput.value; }
    function applyCustomColors(){
      updateColorScheme(primaryColorInput.value, secondaryColorInput.value, 'Custom');
      closeCustomColorPopup();
    }

    function createColorSchemeList(){
      colorSchemeList.innerHTML = '';
      const ucla = nhlTeams.find(t => t.name.startsWith('UCLA'));
      const coreTeams = nhlTeams.filter(t => t !== ucla);

      coreTeams.forEach(team => addSchemeCard(team));
      if (ucla) addSchemeCard(ucla);

      const li = document.createElement('li');
      li.className = 'scheme';
      li.innerHTML = `
        <div class="swatches">
          <div class="swatch" style="background:#000"></div>
          <div class="swatch" style="background:#000"></div>
        </div>
        <div class="team-name">Custom</div>
        <button class="select-button">Select your own</button>
      `;
      li.querySelector('button').onclick = () => { openCustomColorPopup(); closeColorSchemePopup(); };
      colorSchemeList.appendChild(li);

      function addSchemeCard(team){
        const li = document.createElement('li');
        li.className = 'scheme';
        li.innerHTML = `
          <div class="swatches">
            <div class="swatch" style="background:${team.colors[0]}"></div>
            <div class="swatch" style="background:${team.colors[1]}"></div>
          </div>
          <div class="team-name">${escapeHtml(team.name)}</div>
          <button class="select-button">Select</button>
        `;
        li.querySelector('button').onclick = () => {
          updateColorScheme(team.colors[0], team.colors[1], team.name);
          closeColorSchemePopup();
        };
        colorSchemeList.appendChild(li);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      createColorSchemeList();
      updateColorScheme('#6F263D','#236192','Colorado Avalanche');
      renderTagChips();
    });

    // Optional html2canvas loader
    enableHtml2canvas.addEventListener('change', () => {
      if (enableHtml2canvas.checked){
        ensureHtml2canvasLoaded();
      }
    });

    function ensureHtml2canvasLoaded(){
      if (window.html2canvas) return;
      const s = document.createElement('script');
      s.src = "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
      s.async = true;
      s.onerror = () => { alert("Could not load html2canvas. Screenshot will use Print-to-PDF instead."); };
      document.head.appendChild(s);
    }

 // ---------- TAG CHIPS (rating modal only) ----------
// ---------- TAG CHIPS (rating modal only) ----------
function renderTagChips(){
  tagRow.innerHTML = '';

  // Keep a stable order that reads well in a 2-col grid:
  // Good moves first, then warnings, then highlight.
  const order = [
    'Evidence',
    'BuildsOnOthers',
    'AsksQuestion',
    'Clarifies',
    'ConnectsTexts',
    'WrongButBold',
    'Dominates',
    'OffTopic',
    'Repeats',
    'GreatInsight'
  ];

  const byKey = new Map(TAGS.map(t => [t.key, t]));
  order.forEach(key => {
    const t = byKey.get(key);
    if (!t) return;

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'chip';
    btn.dataset.tag = t.key;

    // Show short, consistent hotkey badge (letter only).
    // Put the full combos in the tooltip so chips stay compact.
    btn.title = `${t.label.replace(/^(\S+)\s/, '')} ‚Äî Hotkey: ${t.hk}`;

    btn.innerHTML = `${escapeHtml(t.label)} <span class="hk" aria-hidden="true">${escapeHtml(t.letter)}</span>`;
    btn.onclick = () => toggleTag(t.key, btn);

    tagRow.appendChild(btn);
  });
}    function toggleTag(key, el){
      if (selectedTagsForEntry.has(key)){
        selectedTagsForEntry.delete(key);
        el.classList.remove('active');
      }else{
        selectedTagsForEntry.add(key);
        el.classList.add('active');
      }
    }

    function syncChipActiveStates(){
      tagRow.querySelectorAll('.chip').forEach(ch => {
        const k = ch.dataset.tag;
        ch.classList.toggle('active', selectedTagsForEntry.has(k));
      });
    }

    function clearTagSelection(){
      selectedTagsForEntry.clear();
      tagRow.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
    }

    function tagsForEntryAsLabels(){
      const map = new Map(TAGS.map(t => [t.key, t.label.replace(/^.*?\s/, '')])); // remove emoji + space
      return Array.from(selectedTagsForEntry).map(k => map.get(k) || k);
    }

    // ---------- DRAWER ----------
    function openDrawer(){
      drawer.classList.add('open');
      drawerBackdrop.classList.add('open');
      drawer.setAttribute('aria-hidden','false');
    }
    function closeDrawer(){
      drawer.classList.remove('open');
      drawerBackdrop.classList.remove('open');
      drawer.setAttribute('aria-hidden','true');
    }
    function toggleDrawer(){
      if (drawer.classList.contains('open')) closeDrawer(); else openDrawer();
    }

    function switchTab(which){
      if (which === 'log'){
        tabLog.classList.add('active');
        tabReport.classList.remove('active');
        logPanel.style.display = 'block';
        reportPanel.style.display = 'none';
        copyLogButton.style.display = 'inline-flex';
        copyReportButton.style.display = 'none';
      }else{
        tabReport.classList.add('active');
        tabLog.classList.remove('active');
        logPanel.style.display = 'none';
        reportPanel.style.display = 'block';
        copyLogButton.style.display = 'none';
        copyReportButton.style.display = 'inline-flex';
      }
      openDrawer();
    }

    // ---------- SETUP FLOW ----------
    document.getElementById('discussionTitle').addEventListener('keydown', (e) => {
      if (e.key === 'Enter'){ e.preventDefault(); startDiscussion(); }
    });

    function startDiscussion(){
      const titleInput = document.getElementById('discussionTitle').value.trim();
      if (!titleInput){ alert('Please enter a title.'); return; }

      const date = new Date().toLocaleDateString();
      discussionTitleDisplay.textContent = `${titleInput}`;
      discussionDateDisplay.textContent = `${date}`;

      document.getElementById('discussionDetails').style.display = 'none';
      participantFormWrap.style.display = 'block';
      participantForm.querySelector('#name').focus();
    }

    participantForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const nameInput = document.getElementById('name');
      const val = nameInput.value.trim();
      if (!val) return;
      if (participants.length >= 29){ alert('Maximum of 29 participants reached'); return; }

      const exists = participants.some(p => p.name.trim().toLowerCase() === val.toLowerCase());
      if (exists){
        const ok = confirm('Already exists. Add anyway?');
        if (!ok){ nameInput.select(); return; }
      }

      addParticipant(val);
      nameInput.value = '';
      nameInput.focus();
    });

    function addParticipant(name){
      const id = uuid();
      participants.push({
        id,
        name,
        x:0,y:0,
        ratings:[],
        comments:[],
        startTimes:[],
        endTimes:[],
        notes:[],
        speakCount:0,
        tagsPerEntry: [],
        tagCounts: {},
        hotkeyLabel: ''
      });
      updateLogCount();
    }

    function doneAddingParticipants(){
      participantFormWrap.style.display = 'none';

      discussionEnded = false;
      selectedParticipantId = null;

      placeParticipants();

      endDiscussionButton.style.display = 'inline-flex';
      editParticipantsButton.style.display = 'inline-flex';
      copyLogButton.style.display = 'inline-flex';
      exportScreenshotButton.style.display = 'inline-flex';

      switchTab('log');
      closeDrawer();

      pauseCenter.style.display = 'block';
      replayDock.style.display = 'none';

      hideHeatmap(true);
    }

    // ---------- RESPONSIVE CIRCLE SIZE ----------
    function updateStageSize(){
      const max = 860;
      const min = 520;
      const avail = Math.min(window.innerWidth - 32, max);
      circleDiameter = Math.max(min, Math.min(max, avail));
      circle.style.width = circleDiameter + 'px';
      circle.style.height = circleDiameter + 'px';

      heatCanvas.width = circleDiameter;
      heatCanvas.height = circleDiameter;

      canvas.width = circleDiameter;
      canvas.height = circleDiameter;

      circleRadius = circleDiameter / 2;
      centerX = circleRadius;
      centerY = circleRadius;
    }

    function updateDynamicStageGap(){
      const anyPill = circle.querySelector('.pill');
      if (!anyPill){
        document.documentElement.style.setProperty('--stage-gap-dynamic', '0px');
        return;
      }
      const h = anyPill.getBoundingClientRect().height;
      const half = h / 2;
      const extra = Math.ceil(half + 18);
      document.documentElement.style.setProperty('--stage-gap-dynamic', `${extra}px`);
    }

    window.addEventListener('resize', () => {
      updateStageSize();
      if (participants.length){
        clearParticipants();
        placeParticipants();
        redrawConnections();
        if (heatmapActive) showHeatmap();
        updateDynamicStageGap();
      }
    });
    updateStageSize();

    // ---------- HOTKEY MAPPING ----------
    // 1‚Äì0 => 1..10
    // QWERTYUIOP => 11..20
    // ASDFGHJKL => 21..29
    const HOTKEY_LAYER_1 = ['1','2','3','4','5','6','7','8','9','0'];
    const HOTKEY_LAYER_Q = ['Q','W','E','R','T','Y','U','I','O','P'];
    const HOTKEY_LAYER_A = ['A','S','D','F','G','H','J','K','L'];

    function hotkeyForIndex(idx){
      const n = idx; // 0-based
      if (n >= 0 && n < 10) return HOTKEY_LAYER_1[n];
      if (n >= 10 && n < 20) return HOTKEY_LAYER_Q[n-10];
      if (n >= 20 && n < 29) return HOTKEY_LAYER_A[n-20];
      return '';
    }

    function indexFromKeyEvent(e){
      // digits: use code so it works regardless of shift/caps/etc
      if (e.code && e.code.startsWith('Digit')){
        const d = e.code.replace('Digit',''); // '0'..'9'
        const idx = HOTKEY_LAYER_1.indexOf(d);
        return idx >= 0 ? idx : null;
      }
      // letters
      const k = String(e.key || '').toUpperCase();
      if (k.length !== 1) return null;
      let idx = HOTKEY_LAYER_Q.indexOf(k);
      if (idx >= 0) return 10 + idx;
      idx = HOTKEY_LAYER_A.indexOf(k);
      if (idx >= 0) return 20 + idx;
      return null;
    }

    // ---------- PARTICIPANT PLACEMENT ----------
    function cssNumVar(name, fallback){
      const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : fallback;
    }

    function placeParticipants(){
      updateStageSize();
      const num = participants.length;

      clearParticipants();

      for (let i=0;i<num;i++){
        participants[i].hotkeyLabel = hotkeyForIndex(i);
      }

      // Place pills to "hug" the circle rim:
      // center radius is slightly inside the circle, so the pill overlaps the rim neatly.
      const pillH = cssNumVar('--pill-h', 56);
      const inset = pillH * 0.22; // tweak: 0.20‚Äì0.28 if you want more/less overlap
      const rPlace = Math.max(0, circleRadius - inset);

      for (let i=0;i<num;i++){
        const angle = (i / num) * (Math.PI*2) - Math.PI/2;
        const x = centerX + rPlace * Math.cos(angle);
        const y = centerY + rPlace * Math.sin(angle);

        const p = participants[i];

        const div = document.createElement('div');
        div.className = 'participant';
        div.dataset.pid = p.id;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;

        div.innerHTML = `
          <div id="pill${p.id}" class="pill" title="Click to record speaking">
            <div class="count" id="speakCount${p.id}">${p.speakCount || 0}</div>
            <div class="name" id="name${p.id}" title="${escapeHtml(p.name)}">${escapeHtml(p.name)}</div>
          </div>

          <button class="notes-out" title="Notes" onclick="event.stopPropagation(); openNotesBoxById('${p.id}')">
            <span class="icon">üìù</span>
            <span class="hk" aria-hidden="true">${escapeHtml(p.hotkeyLabel || '')}</span>
          </button>
        `;
        circle.appendChild(div);

        div.querySelector('.pill').addEventListener('click', () => recordSpeakingById(p.id));

        p.x = x;
        p.y = y;
      }

      requestAnimationFrame(() => {
        updateDynamicStageGap();
        positionNotesButtonsOutsideCircle();
        applySelectedHighlight();
        redrawConnections();
        if (heatmapActive) showHeatmap();
      });
    }

    function clearParticipants(){
      circle.querySelectorAll('.participant').forEach(el => el.remove());
    }

    function positionNotesButtonsOutsideCircle(){
      // Place notes button outside pill, outward from center, so it clearly sits outside the circle rim.
      const auxD = cssNumVar('--aux-d', 44);
      const auxR = auxD / 2;
      const gap = Math.max(8, Math.min(14, circleDiameter * 0.014));

      participants.forEach(p => {
        const container = circle.querySelector(`.participant[data-pid="${p.id}"]`);
        if (!container) return;

        const pill = container.querySelector('.pill');
        if (!pill) return;

        const pillRect = pill.getBoundingClientRect();
        const w = pillRect.width;
        const h = pillRect.height;

        // outward direction based on placement
        const vx = (p.x - centerX);
        const vy = (p.y - centerY);
        const len = Math.hypot(vx,vy) || 1;
        const ux = vx / len;
        const uy = vy / len;

        // approximate edge distance for pill (rectangle-ish)
        const edgeDist = Math.abs(ux) * (w/2) + Math.abs(uy) * (h/2);
        const dist = edgeDist + auxR + gap;

        const nx = Math.round(ux * dist);
        const ny = Math.round(uy * dist);

        container.style.setProperty('--nx', nx + 'px');
        container.style.setProperty('--ny', ny + 'px');
      });
    }

    // ---------- KEYBOARD SELECTION (select -> speak) ----------
    function isRatingOpen(){ return ratingBox.style.display !== 'none'; }

    function isOverlayOpen(){
      const overlays = [notesOverlay, colorSchemePopup, customColorPopup, confirmRestartPopup, editParticipantsPopup];
      return overlays.some(o => o && o.style.display === 'flex');
    }

    function isTypingTarget(el){
      if (!el) return false;
      const tag = (el.tagName || '').toUpperCase();
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || el.isContentEditable;
    }

    function selectParticipantById(id){
      selectedParticipantId = id;
      applySelectedHighlight();
    }

    function applySelectedHighlight(){
      participants.forEach(p => {
        const pill = document.getElementById(`pill${p.id}`);
        if (!pill) return;
        pill.classList.toggle('selected', p.id === selectedParticipantId && !pill.classList.contains('active'));
      });
    }

    document.addEventListener('keydown', (e) => {
      if (discussionEnded) return;

      // Tag hotkeys while rating modal is open handled in separate block
      if (isRatingOpen()) return;

      if (isOverlayOpen()) return;

      if (isTypingTarget(document.activeElement)) return;

      if (!participants.length) return;

      const idx = indexFromKeyEvent(e);
      if (idx == null) return;
      if (idx < 0 || idx >= participants.length) return;

      e.preventDefault();

      const pid = participants[idx].id;

      if (selectedParticipantId === pid){
        recordSpeakingById(pid);
      }else{
        selectParticipantById(pid);
      }
    });

// ---------- Rating modal hotkeys (Ctrl+Enter, 1‚Äì5, Esc, Alt/Option+tag, Cmd+Shift+tag) ----------
document.addEventListener('keydown', (e) => {
  if (!isRatingOpen()) return;

  const k = String(e.key || '').toUpperCase();

  // Tag toggles:
  // - Option/Alt + Letter
  // - Command + Shift + Letter
  // (Do not require focus changes; safe while typing in textarea)
  const isAltTag = e.altKey && !e.ctrlKey && !e.metaKey && k.length === 1;
  const isCmdShiftTag = e.metaKey && e.shiftKey && !e.ctrlKey && k.length === 1;

  if ((isAltTag || isCmdShiftTag) && TAG_HOTKEYS.has(k)){
    e.preventDefault();
    const tagKey = TAG_HOTKEYS.get(k);

    if (selectedTagsForEntry.has(tagKey)) selectedTagsForEntry.delete(tagKey);
    else selectedTagsForEntry.add(tagKey);

    syncChipActiveStates();
    return;
  }

  if (e.ctrlKey && e.key === 'Enter'){
    e.preventDefault();
    startTimer();
    return;
  }

  // rating 1‚Äì5
  if (e.key >= '1' && e.key <= '5'){
    selectRating(parseInt(e.key,10));
  }

  if (e.key === 'Escape'){
    ratingBox.style.display = 'none';
    pauseCenter.classList.remove('hidden');
    clearTagSelection();
  }
});
    notesOverlay.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'Enter'){ saveNotes(); }
      if (e.key === 'Escape'){ closeNotesBox(); }
    });

    // ---------- SPEAKING / LOGIC ----------
    function setNowSpeaking(id){
      // removed (kept for replay compatibility)
      return;
    }

    function setActivePill(activeId){
      participants.forEach((p) => {
        const pill = document.getElementById(`pill${p.id}`);
        if (!pill) return;
        pill.classList.remove('active','pulse');
        if (p.id === activeId){
          pill.classList.add('active','pulse');
        }
      });
      applySelectedHighlight();
    }

    window.recordSpeakingById = function(id){
      const index = idxById(id);
      if (index < 0) return;

      const now = new Date();
      const participant = participants[index];

      selectedParticipantId = id;
      applySelectedHighlight();

      participant.speakCount += 1;
      const countEl = document.getElementById(`speakCount${participant.id}`);
      if (countEl) countEl.textContent = participant.speakCount;

      // end previous speaker if switching
      if (currentSpeakerId && currentSpeakerId !== id){
        const prev = getParticipantById(currentSpeakerId);
        if (prev && prev.startTimes.length){
          const dur = (now - prev.startTimes[prev.startTimes.length - 1]) / 1000;
          prev.endTimes.push(dur);
          updateDurationInLog(prev.id, prev.endTimes.length - 1, dur);
        }
      }

      // clicking same speaker again toggles off (end segment)
      if (currentSpeakerId && currentSpeakerId === id){
        const curr = getParticipantById(currentSpeakerId);
        if (curr && curr.startTimes.length){
          const dur = (now - curr.startTimes[curr.startTimes.length - 1]) / 1000;
          curr.endTimes.push(dur);
          updateDurationInLog(curr.id, curr.endTimes.length - 1, dur);
        }
        currentSpeakerId = null;
        setActivePill(null);
        setNowSpeaking(null);
        ratingBox.style.display = 'none';
        pauseCenter.classList.remove('hidden');
        clearTagSelection();
        return;
      }

      // start new segment
      currentSpeakerId = id;
      participant.startTimes.push(now);

      // create connection from last speaker to current
      if (lastSpokenId && lastSpokenId !== id){
        const from = getParticipantById(lastSpokenId);
        const to = getParticipantById(id);
        if (from && to){
          const key = `${lastSpokenId}-${id}`;
          const rkey = `${id}-${lastSpokenId}`;
          if (connectionCounts[key]) connectionCounts[key] += 1;
          else if (connectionCounts[rkey]) connectionCounts[rkey] += 1;
          else connectionCounts[key] = 1;

          const thickness = connectionCounts[key] || connectionCounts[rkey] || 1;
          connections.push({ fromId: from.id, toId: to.id, fromName: from.name, toName: to.name, thickness });
          animateConnection(from.id, to.id, thickness, 'var(--secondary-color)', 220, () => {});
        }
      }

      lastSpokenId = id;

      resetRating();
      clearTagSelection();

      ratingBox.style.display = 'block';
      pauseCenter.classList.add('hidden');
      document.getElementById('comment').focus();

      setActivePill(id);
      setNowSpeaking(id);

      if (heatmapActive){
        hideHeatmap(true);
      }
    };

    function selectRating(rating){
      selectedRating = rating;
      ratingBox.querySelectorAll('.rating-option').forEach(opt => opt.classList.remove('selected'));
      ratingBox.querySelectorAll('.rating-option')[rating - 1].classList.add('selected');
    }
    function resetRating(){
      selectedRating = null;
      ratingBox.querySelectorAll('.rating-option').forEach(opt => opt.classList.remove('selected'));
    }

    function startTimer(){
      if (!currentSpeakerId) return;

      ratingBox.style.display = 'none';
      pauseCenter.classList.remove('hidden');

      const participant = getParticipantById(currentSpeakerId);
      if (!participant) return;

      const baseComment = document.getElementById('comment').value || '';
      const tagLabels = tagsForEntryAsLabels();

      participant.tagsPerEntry.push(tagLabels);
      tagLabels.forEach(lbl => {
        participant.tagCounts[lbl] = (participant.tagCounts[lbl] || 0) + 1;
      });

      participant.ratings.push(selectedRating);
      participant.comments.push(baseComment);

      const seq = participant.ratings.length - 1;

      const row = logTableBody.insertRow();
      row.dataset.pid = participant.id;
      row.dataset.seq = String(seq);

      row.insertCell(0).textContent = participant.name;
      row.insertCell(1).textContent = new Date().toLocaleString();

      const ratingCell = row.insertCell(2);
      ratingCell.className = 'cell-editable';
      ratingCell.textContent = selectedRating !== null ? selectedRating : '';
      ratingCell.title = 'Click to edit rating';

      const commentCell = row.insertCell(3);
      commentCell.className = 'cell-editable';
      const appended = tagLabels.length
        ? (baseComment ? `${baseComment}\nTags: ${tagLabels.join(', ')}` : `Tags: ${tagLabels.join(', ')}`)
        : baseComment;
      commentCell.textContent = appended;
      commentCell.title = 'Click to edit comment';

      row.insertCell(4).textContent = '';

      document.getElementById('comment').value = '';
      resetRating();
      clearTagSelection();
      updateLogCount();
    }

    function updateLogCount(){
      const rows = Array.from(logTableBody.rows);
      const contribs = rows.filter(r => r.cells[1] && r.cells[1].textContent.trim() !== '').length;
      logCount.textContent = String(contribs);
    }

    function updateDurationInLog(pid, seq, duration){
      const rows = Array.from(logTableBody.rows);
      for (let i = rows.length - 1; i >= 0; i--){
        if (rows[i].dataset.pid === pid && rows[i].dataset.seq === String(seq)){
          rows[i].cells[4].textContent = duration.toFixed(2) + "s";
          break;
        }
      }
    }

    function endDiscussion(){
      const now = new Date();
      if (currentSpeakerId){
        const curr = getParticipantById(currentSpeakerId);
        if (curr && curr.startTimes.length){
          const dur = (now - curr.startTimes[curr.startTimes.length - 1]) / 1000;
          curr.endTimes.push(dur);
          updateDurationInLog(curr.id, curr.endTimes.length - 1, dur);
        }
      }

      ratingBox.style.display = 'none';
      clearTagSelection();

      currentSpeakerId = null;
      setActivePill(null);
      setNowSpeaking(null);

      pauseCenter.style.display = 'none';

      replayDock.style.display = 'block';
      replayDock.setAttribute('aria-hidden','false');

      copyBothButton.style.display = 'inline-flex';
      restartDiscussionButton.style.display = 'inline-flex';
      generateReportButton.style.display = 'inline-flex';
      exportScreenshotButton.style.display = 'inline-flex';

      copyLogButton.style.display = 'inline-flex';
      switchTab('log');
      openDrawer();

      hideHeatmap(true);

      discussionEnded = true;
      selectedParticipantId = null;
      applySelectedHighlight();
    }

    // ---------- INLINE EDITING (log table) ----------
    logTableBody.addEventListener('click', (e) => {
      const td = e.target.closest('td');
      if (!td) return;
      const tr = td.closest('tr');
      if (!tr) return;

      const colIndex = td.cellIndex;
      if (colIndex !== 2 && colIndex !== 3) return;
      if (td.querySelector('input,select,textarea')) return;

      const pid = tr.dataset.pid;
      const seq = parseInt(tr.dataset.seq || '0', 10);
      const p = getParticipantById(pid);
      if (!p) return;

      if (colIndex === 2){
        const current = (td.textContent || '').trim();
        const sel = document.createElement('select');
        sel.className = 'cell-select';
        const optBlank = document.createElement('option');
        optBlank.value = '';
        optBlank.textContent = '';
        sel.appendChild(optBlank);
        for (let i=1;i<=5;i++){
          const o = document.createElement('option');
          o.value = String(i);
          o.textContent = String(i);
          sel.appendChild(o);
        }
        sel.value = current;
        td.textContent = '';
        td.appendChild(sel);
        sel.focus();

        const commit = () => {
          const v = sel.value;
          td.innerHTML = '';
          td.textContent = v;
          p.ratings[seq] = v ? parseInt(v,10) : null;
        };
        sel.addEventListener('change', commit);
        sel.addEventListener('blur', commit);
        sel.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter'){ ev.preventDefault(); commit(); }
          if (ev.key === 'Escape'){ ev.preventDefault(); td.innerHTML=''; td.textContent=current; }
        });
      }else{
        const current = td.textContent || '';
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.className = 'cell-input';
        inp.value = current;
        td.textContent = '';
        td.appendChild(inp);
        inp.focus();
        inp.select();

        const commit = () => {
          const v = inp.value;
          td.innerHTML = '';
          td.textContent = v;
          p.comments[seq] = v;
        };
        inp.addEventListener('blur', commit);
        inp.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter'){ ev.preventDefault(); commit(); }
          if (ev.key === 'Escape'){ ev.preventDefault(); td.innerHTML=''; td.textContent=current; }
        });
      }
    });

    // ---------- LINE GEOMETRY (connect to pill OUTLINE) ----------
    function getPillMetrics(pid){
      const pill = document.getElementById(`pill${pid}`);
      if (!pill) return null;
      const pillRect = pill.getBoundingClientRect();
      const circleRect = circle.getBoundingClientRect();
      const cx = (pillRect.left + pillRect.width/2) - circleRect.left;
      const cy = (pillRect.top + pillRect.height/2) - circleRect.top;
      const rx = pillRect.width / 2;
      const ry = pillRect.height / 2;
      return { cx, cy, rx, ry };
    }

    // Approx pill boundary as ellipse (very good visually for rounded pill)
    function ellipseBoundaryPoint(from, to){
      const dx = to.cx - from.cx;
      const dy = to.cy - from.cy;
      const denom = Math.sqrt((dx*dx)/(from.rx*from.rx) + (dy*dy)/(from.ry*from.ry)) || 1;
      const t = 1 / denom;
      return { x: from.cx + dx * t, y: from.cy + dy * t };
    }

    function getOuterAnchors(fromId, toId){
      const a = getPillMetrics(fromId);
      const b = getPillMetrics(toId);
      if (!a || !b) return {x1:0,y1:0,x2:0,y2:0};

      // boundary points on each pill, facing the other pill
      const p1 = ellipseBoundaryPoint(a, b);
      const p2 = ellipseBoundaryPoint(b, a);

      // tiny inset so stroke doesn't look like it floats off the edge
      const inset = Math.max(1.5, Math.min(3.5, circleDiameter * 0.004));

      const vx1 = a.cx - b.cx;
      const vy1 = a.cy - b.cy;
      const l1 = Math.hypot(vx1, vy1) || 1;
      const ux1 = vx1 / l1;
      const uy1 = vy1 / l1;

      const vx2 = b.cx - a.cx;
      const vy2 = b.cy - a.cy;
      const l2 = Math.hypot(vx2, vy2) || 1;
      const ux2 = vx2 / l2;
      const uy2 = vy2 / l2;

      return {
        x1: p1.x + ux1 * inset,
        y1: p1.y + uy1 * inset,
        x2: p2.x + ux2 * inset,
        y2: p2.y + uy2 * inset
      };
    }

    function redrawConnections(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      clipToCircle(ctx);

      for (const c of connections){
        const { x1,y1,x2,y2 } = getOuterAnchors(c.fromId, c.toId);
        drawLineInstant(x1,y1,x2,y2,c.thickness,'var(--secondary-color)', true);
      }

      unclip(ctx);
    }

    function drawLineInstant(x1,y1,x2,y2,thickness,color,glow){
      ctx.lineWidth = thickness;
      ctx.strokeStyle = color;
      ctx.lineCap = 'round';

      if (glow){
        ctx.shadowColor = 'rgba(35,97,146,.45)';
        ctx.shadowBlur = Math.min(18, 8 + thickness * 2);
      }else{
        ctx.shadowBlur = 0;
      }

      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function animateConnection(fromId, toId, thickness, cssColor, durationMs, onDone){
      const { x1,y1,x2,y2 } = getOuterAnchors(fromId,toId);

      const color = getComputedStyle(document.documentElement)
        .getPropertyValue(cssColor.replace('var(','').replace(')','')).trim() || cssColor;

      const start = performance.now();
      const glow = true;

      function frame(t){
        const p = Math.min(1, (t - start) / durationMs);
        const ex = x1 + (x2 - x1) * p;
        const ey = y1 + (y2 - y1) * p;

        ctx.clearRect(0,0,canvas.width,canvas.height);
        clipToCircle(ctx);

        for (let i=0;i<connections.length-1;i++){
          const c = connections[i];
          const a = getOuterAnchors(c.fromId,c.toId);
          drawLineInstant(a.x1,a.y1,a.x2,a.y2,c.thickness,'var(--secondary-color)', true);
        }

        drawLineInstant(x1,y1,ex,ey,thickness,color,glow);

        unclip(ctx);

        if (p < 1) requestAnimationFrame(frame);
        else onDone && onDone();
      }
      requestAnimationFrame(frame);
    }

    // ---------- REPLAY ----------
    function highlightParticipant(id){
      setActivePill(id);
      setNowSpeaking(id);
    }

    function resetReplayCache(){ window.__replayDrawn = []; }

    function replayDiscussion(speed){
      hideHeatmap(true);
      resetReplayCache();

      ctx.clearRect(0,0,canvas.width,canvas.height);
      let i = 0;

      function step(){
        if (i >= connections.length) {
          setNowSpeaking(null);
          setActivePill(null);
          showHeatmap();
          return;
        }

        const seg = connections[i];
        const fromId = seg.fromId;
        const toId = seg.toId;

        highlightParticipant(fromId);

        const dur = Math.max(220, 750 / speed);
        animateReplaySegment(fromId, toId, seg.thickness, dur, () => {
          highlightParticipant(toId);
          i++;
          setTimeout(step, 120);
        });
      }

      step();
    }

    function replayDiscussionTimed(speed){
      hideHeatmap(true);
      resetReplayCache();

      ctx.clearRect(0,0,canvas.width,canvas.height);
      let i = 0;

      const endTimesCopy = new Map(participants.map(p => [p.id, [...p.endTimes]]));

      function step(){
        if (i >= connections.length) {
          setNowSpeaking(null);
          setActivePill(null);
          showHeatmap();
          return;
        }

        const seg = connections[i];
        const fromId = seg.fromId;
        const toId = seg.toId;

        highlightParticipant(fromId);

        const arr = endTimesCopy.get(toId) || [];
        const durationSpoken = (arr.shift() || 1);
        endTimesCopy.set(toId, arr);

        const dur = Math.max(260, (durationSpoken / speed) * 1000);

        animateReplaySegment(fromId, toId, seg.thickness, dur, () => {
          highlightParticipant(toId);
          i++;
          setTimeout(step, 100);
        });
      }

      step();
    }

    function animateReplaySegment(fromId,toId,thickness,durationMs,onDone){
      const start = performance.now();
      const { x1,y1,x2,y2 } = getOuterAnchors(fromId,toId);

      function frame(t){
        const p = Math.min(1, (t - start) / durationMs);

        ctx.clearRect(0,0,canvas.width,canvas.height);
        clipToCircle(ctx);

        if (window.__replayDrawn == null) window.__replayDrawn = [];
        for (const seg of window.__replayDrawn){
          drawLineInstant(seg.x1,seg.y1,seg.x2,seg.y2,seg.thickness,'var(--secondary-color)', true);
        }

        const ex = x1 + (x2-x1)*p;
        const ey = y1 + (y2-y1)*p;
        drawLineInstant(x1,y1,ex,ey,thickness,'var(--secondary-color)', true);

        unclip(ctx);

        if (p < 1){
          requestAnimationFrame(frame);
        }else{
          window.__replayDrawn.push({ x1,y1,x2,y2,thickness });
          onDone && onDone();
        }
      }
      requestAnimationFrame(frame);
    }

    // ---------- REPORT ----------
    function generateReport(){
      reportTableBody.innerHTML = '';
      notesReportTableBody.innerHTML = '';

      const totalDuration = participants.reduce((sum,p) => sum + p.endTimes.reduce((a,b)=>a+b,0), 0);

      participants.forEach(p => {
        const ratings = p.ratings.filter(r => r !== null && r !== undefined && r !== '');
        const avg = ratings.length ? (ratings.reduce((a,b)=>a+b,0)/ratings.length).toFixed(2) : 'N/A';

        const air = p.endTimes.reduce((a,b)=>a+b,0);
        const minutes = Math.floor(air/60);
        const seconds = air % 60;
        const formatted = `${minutes}m ${seconds.toFixed(2)}s`;
        const domination = totalDuration > 0 ? ((air/totalDuration)*100).toFixed(2)+'%' : '0%';

        const entries = Object.entries(p.tagCounts || {});
        entries.sort((a,b) => b[1] - a[1]);
        const tagSummary = entries.length ? entries.map(([k,v]) => `${k}√ó${v}`).join(', ') : '';

        const row = reportTableBody.insertRow();
        row.insertCell(0).textContent = p.name;
        row.insertCell(1).textContent = ratings.join(', ');
        row.insertCell(2).textContent = avg;
        row.insertCell(3).textContent = formatted;
        row.insertCell(4).textContent = domination;
        row.insertCell(5).textContent = tagSummary;

        const nrow = notesReportTableBody.insertRow();
        nrow.insertCell(0).textContent = p.name;
        nrow.insertCell(1).textContent = p.notes.join('\n');
      });

      tabReport.disabled = false;
      reportReady.textContent = '‚úì';

      copyReportButton.style.display = 'inline-flex';
      copyBothButton.style.display = 'inline-flex';

      switchTab('report');
      openDrawer();
    }

    // ---------- COPY ----------
    function copyNodeAsTSV(tableEl){
      const rows = Array.from(tableEl.querySelectorAll('tr'));
      const lines = rows.map(r => {
        const cells = Array.from(r.children).map(td => (td.innerText || '').replace(/\s+\n/g,'\n').replace(/\s+/g,' ').trim());
        return cells.join('\t');
      });
      return lines.join('\n');
    }

    async function copyToClipboard(text){
      try{
        await navigator.clipboard.writeText(text);
      }catch(e){
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
      }
    }

    async function copyLog(){
      const text = copyNodeAsTSV(document.getElementById('logTable'));
      await copyToClipboard(text);
      alert('Discussion log copied (TSV).');
    }

    async function copyReport(){
      const reportText = copyNodeAsTSV(document.getElementById('reportTable'));
      const notesText2 = copyNodeAsTSV(document.getElementById('notesReportTable'));
      await copyToClipboard(reportText + "\n\n" + notesText2);
      alert('Report copied (TSV).');
    }

    async function copyBoth(){
      const logText = copyNodeAsTSV(document.getElementById('logTable'));
      const reportText = copyNodeAsTSV(document.getElementById('reportTable'));
      const notesText2 = copyNodeAsTSV(document.getElementById('notesReportTable'));
      const combined =
        "REPORT\n" + reportText + "\n\nNOTES\n" + notesText2 + "\n\nLOG\n" + logText;
      await copyToClipboard(combined);
      alert('Report + Notes + Log copied (TSV).');
    }

    // ---------- NOTES (timestamped) ----------
    function openNotesBoxById(pid){
      const p = getParticipantById(pid);
      if (!p) return;
      currentNotesParticipantId = pid;
      notesBoxTitle.textContent = `Notes about ${p.name}`;
      notesText.value = '';
      notesOverlay.style.display = 'flex';
      notesText.focus();
    }
    function saveNotes(){
      const note = notesText.value.trim();
      if (currentNotesParticipantId && note){
        const p = getParticipantById(currentNotesParticipantId);
        if (p){
          const t = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
          p.notes.push(`${t}: ${note}`);
        }
      }
      closeNotesBox();
    }
    function closeNotesBox(){
      notesOverlay.style.display = 'none';
      currentNotesParticipantId = null;
    }

    // ---------- PAUSE ----------
    function pauseTimer(){
      if (currentSpeakerId){
        const now = new Date();
        const curr = getParticipantById(currentSpeakerId);
        if (curr && curr.startTimes.length){
          const dur = (now - curr.startTimes[curr.startTimes.length - 1]) / 1000;
          curr.endTimes.push(dur);
          updateDurationInLog(curr.id, curr.endTimes.length - 1, dur);
        }
        currentSpeakerId = null;
        ratingBox.style.display = 'none';
        pauseCenter.classList.remove('hidden');
        setActivePill(null);
        setNowSpeaking(null);
        clearTagSelection();
      }
    }

    // ---------- RESTART ----------
    function confirmRestartDiscussion(){ confirmRestartPopup.style.display = 'flex'; }
    function closeConfirmRestartPopup(){ confirmRestartPopup.style.display = 'none'; }
    function restartDiscussion(){ location.reload(); }

    // ---------- EDIT PARTICIPANTS ----------
    function openEditParticipantsPopup(){ editParticipantsPopup.style.display = 'flex'; }
    function closeEditParticipantsPopup(){
      editParticipantsPopup.style.display = 'none';
      reorderParticipantsContainer.style.display = 'none';
      renameParticipantsContainer.style.display = 'none';
    }

    function addNewParticipant(){
      const inp = document.getElementById('newParticipantName');
      const name = inp.value.trim();
      if (!name){ alert('Please enter a name.'); return; }
      if (participants.length >= 29){ alert('Maximum of 29 participants reached'); return; }

      const exists = participants.some(p => p.name.trim().toLowerCase() === name.toLowerCase());
      if (exists){
        const ok = confirm('Already exists. Add anyway?');
        if (!ok){ inp.select(); return; }
      }

      addParticipant(name);
      placeParticipants();
      redrawConnections();
      if (heatmapActive) showHeatmap();
      inp.value = '';
      closeEditParticipantsPopup();
    }

    function openReorderParticipants(){
      reorderParticipantsContainer.style.display = 'block';
      renameParticipantsContainer.style.display = 'none';
      reorderParticipantsList.innerHTML = '';

      participants.forEach((p, idx) => {
        const li = document.createElement('li');
        li.draggable = true;
        li.dataset.index = idx;
        li.style.display = 'flex';
        li.style.alignItems = 'center';
        li.style.justifyContent = 'space-between';
        li.style.padding = '10px';
        li.style.border = '1px solid rgba(0,0,0,.10)';
        li.style.borderRadius = '14px';
        li.style.background = 'rgba(255,255,255,.80)';
        li.style.cursor = 'grab';
        li.innerHTML = `<strong>${escapeHtml(p.name)}</strong><span style="color:var(--muted);font-weight:300;">drag</span>`;
        li.addEventListener('dragstart', handleDragStart);
        li.addEventListener('dragover', handleDragOver);
        li.addEventListener('drop', handleDrop);
        li.addEventListener('dragend', handleDragEnd);
        reorderParticipantsList.appendChild(li);
      });
    }

    let dragSrcEl = null;
    function handleDragStart(e){ dragSrcEl = this; this.style.opacity = '0.5'; }
    function handleDragOver(e){ e.preventDefault(); return false; }
    function handleDrop(e){
      e.stopPropagation();
      if (dragSrcEl !== this){
        const srcIndex = parseInt(dragSrcEl.dataset.index,10);
        const tgtIndex = parseInt(this.dataset.index,10);
        [participants[srcIndex], participants[tgtIndex]] = [participants[tgtIndex], participants[srcIndex]];
        openReorderParticipants();
      }
      return false;
    }
    function handleDragEnd(e){ this.style.opacity = '1'; }

    function saveReorderedParticipants(){
      placeParticipants();
      redrawConnections();
      if (heatmapActive) showHeatmap();
      reorderParticipantsContainer.style.display = 'none';
    }

    function openRenameParticipants(){
      renameParticipantsContainer.style.display = 'block';
      reorderParticipantsContainer.style.display = 'none';
      renameParticipantsList.innerHTML = '';

      participants.forEach((p, idx) => {
        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.gap = '10px';
        li.style.alignItems = 'center';
        li.innerHTML = `
          <input type="text" id="renameInput${idx}" value="${escapeHtml(p.name)}" />
          <button class="btn secondary" type="button" onclick="renameParticipant(${idx})">Save</button>
        `;
        renameParticipantsList.appendChild(li);
      });
    }

    function renameParticipant(index){
      const inp = document.getElementById(`renameInput${index}`);
      const newName = inp.value.trim();
      if (!newName){ alert('Please enter a valid name.'); return; }

      const exists = participants.some((p,i) => i !== index && p.name.trim().toLowerCase() === newName.toLowerCase());
      if (exists){
        const ok = confirm('Already exists. Rename anyway?');
        if (!ok){ inp.select(); return; }
      }

      const p = participants[index];
      p.name = newName;

      const nameEl = document.getElementById(`name${p.id}`);
      if (nameEl){
        nameEl.textContent = newName;
        nameEl.title = newName;
      }

      Array.from(logTableBody.rows).forEach(r => {
        if (r.dataset.pid === p.id){
          r.cells[0].textContent = newName;
        }
      });

      if (currentNotesParticipantId === p.id){
        notesBoxTitle.textContent = `Notes about ${p.name}`;
      }

      redrawConnections();
      if (heatmapActive) showHeatmap();
      updateLogCount();
    }

    function saveRenamedParticipants(){
      renameParticipantsContainer.style.display = 'none';
      closeEditParticipantsPopup();
    }

    // ---------- SCREENSHOT / PRINT ----------
    async function exportScreenshot(){
      if (window.html2canvas){
        try{
          const drawerWasOpen = drawer.classList.contains('open');
          closeDrawer();

          const target = document.querySelector('.wrap');
          const canvasShot = await window.html2canvas(target, {
            backgroundColor: "#ffffff",
            scale: 2,
            useCORS: true
          });

          if (drawerWasOpen) openDrawer();

          const dataUrl = canvasShot.toDataURL("image/png");
          const w = window.open('', '_blank');
          if (!w){ alert('Popup blocked. Allow popups to export screenshot.'); return; }
          w.document.write(`
            <title>Discussion Tracker Screenshot</title>
            <style>body{margin:0;background:#111;display:flex;align-items:center;justify-content:center;min-height:100vh;} img{max-width:100%;height:auto;}</style>
            <img src="${dataUrl}" alt="Screenshot" />
          `);
          w.document.close();
          return;
        }catch(err){
          alert('Screenshot capture failed. Falling back to Print-to-PDF.');
        }
      }
      window.print();
    }

   function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function hexToRgb(hex){
const h = hex.trim().replace('#','');
const r = parseInt(h.slice(0,2),16);
const g = parseInt(h.slice(2,4),16);
const b = parseInt(h.slice(4,6),16);
return {r,g,b};
}

function rgbToHsl(r,g,b){
r/=255; g/=255; b/=255;
const max = Math.max(r,g,b), min = Math.min(r,g,b);
let h, s, l = (max+min)/2;
if(max===min){ h=s=0; }
else{
const d = max-min;
s = l>0.5 ? d/(2-max-min) : d/(max+min);
switch(max){
case r: h=(g-b)/d+(g<b?6:0); break;
case g: h=(b-r)/d+2; break;
case b: h=(r-g)/d+4; break;
}
h/=6;
}
return {h,s,l};
}

function hslToRgb(h,s,l){
let r,g,b;
if(s===0){ r=g=b=l; }
else{
const hue2rgb=(p,q,t)=>{
if(t<0)t+=1;if(t>1)t-=1;
if(t<1/6)return p+(q-p)*6*t;
if(t<1/2)return q;
if(t<2/3)return p+(q-p)*(2/3-t)*6;
return p;
};
const q=l<0.5?l*(1+s):l+s-l*s;
const p=2*l-q;
r=hue2rgb(p,q,h+1/3);
g=hue2rgb(p,q,h);
b=hue2rgb(p,q,h-1/3);
}
return {r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)};
}

function colorForDominance(t){
const primary = getComputedStyle(document.documentElement)
.getPropertyValue('--primary-color').trim();

const rgb = hexToRgb(primary);
const hsl = rgbToHsl(rgb.r,rgb.g,rgb.b);

const dominance = Math.pow(clamp01(t),0.55);

hsl.s = clamp01(hsl.s * (1 + dominance*0.6));
hsl.l = clamp01(hsl.l - dominance*0.15);

if(dominance > 0.8){
hsl.h = clamp01(hsl.h - 0.02);
}

return hslToRgb(hsl.h,hsl.s,hsl.l);
}

function alphaForDominance(t){
const d = Math.pow(clamp01(t),0.6);
return 0.08 + d*0.75;
}

function renderHeatmapAngularBlended(maxPct, pctMap){

heatCtx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
clipToCircle(heatCtx);

const rOuter = circleRadius-2;

participants.forEach(p=>{
const pct = pctMap.get(p.id)||0;
const t = pct/maxPct;

const rgb = colorForDominance(t);
const alpha = alphaForDominance(t);

const g = heatCtx.createRadialGradient(
p.x,p.y,
circleRadius*0.05,
p.x,p.y,
circleRadius*0.85
);

g.addColorStop(0,`rgba(${rgb.r},${rgb.g},${rgb.b},${Math.min(1,alpha)})`);
g.addColorStop(0.25,`rgba(${rgb.r},${rgb.g},${rgb.b},${alpha*0.7})`);
g.addColorStop(0.75,`rgba(${rgb.r},${rgb.g},${rgb.b},${alpha*0.15})`);
g.addColorStop(1,`rgba(${rgb.r},${rgb.g},${rgb.b},0)`);

heatCtx.fillStyle=g;
heatCtx.beginPath();
heatCtx.arc(centerX,centerY,rOuter,0,Math.PI*2);
heatCtx.fill();
});

unclip(heatCtx);
}
    function computeDominationPercents(){
      const total = participants.reduce((sum,p) => sum + p.endTimes.reduce((a,b)=>a+b,0), 0);
      const arr = participants.map(p => {
        const air = p.endTimes.reduce((a,b)=>a+b,0);
        const pct = total > 0 ? (air/total)*100 : 0;
        return { id:p.id, pct };
      });
      const maxPct = arr.reduce((m,o)=>Math.max(m,o.pct), 0) || 0.00001;
      return { arr, total, maxPct };
    }

    function angleOfPoint(x,y){ return Math.atan2(y - centerY, x - centerX); }
    function normalizeAngle(a){
      let x = a;
      while (x < 0) x += Math.PI*2;
      while (x >= Math.PI*2) x -= Math.PI*2;
      return x;
    }

    function showHeatmap(){
      if (!participants.length) return;

      heatmapActive = true;
      heatStatusText.textContent = 'Heatmap: on';

      const { arr, maxPct } = computeDominationPercents();
      const pctMap = new Map(arr.map(o => [o.id, o.pct]));

      // Percent badges removed by request ‚Äî heatmap only.
      renderHeatmapAngularBlended(maxPct, pctMap);
    }

    function hideHeatmap(silent){
      heatmapActive = false;
      heatStatusText.textContent = 'Heatmap: off';
      heatCtx.clearRect(0,0,heatCanvas.width,heatCanvas.height);

      if (!silent) redrawConnections();
    }

    function renderHeatmapAngularBlended(maxPct, pctMap){
      heatCtx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
      clipToCircle(heatCtx);

      const num = participants.length;
      if (num === 0){
        unclip(heatCtx);
        return;
      }

      const angles = participants.map(p => normalizeAngle(angleOfPoint(p.x, p.y)));

      const steps = Math.max(720, num * 180);
      const dTheta = (Math.PI*2) / steps;

      const boundaryWidth = Math.max(0.10, Math.min(0.22, (Math.PI*2)/(num*3)));
      const rOuter = circleRadius - 2;

      const sorted = participants
        .map((p,i)=>({i, a: angles[i]}))
        .sort((x,y)=>x.a - y.a);

      function findBracket(theta){
        let lo = 0, hi = sorted.length - 1;
        while (lo <= hi){
          const mid = (lo + hi) >> 1;
          if (sorted[mid].a <= theta) lo = mid + 1;
          else hi = mid - 1;
        }
        const rightIdx = lo % sorted.length;
        const leftIdx = (rightIdx - 1 + sorted.length) % sorted.length;
        return { left: sorted[leftIdx], right: sorted[rightIdx] };
      }

      for (let s=0; s<steps; s++){
        const theta = s * dTheta;
        const mid = theta + dTheta/2;

        const { left, right } = findBracket(mid);
        const aL = left.a;
        const aR = right.a;

        let span = aR - aL;
        if (span < 0) span += Math.PI*2;
        let along = mid - aL;
        if (along < 0) along += Math.PI*2;
        const u = span > 0 ? along / span : 0;

        const bwFrac = Math.min(0.45, boundaryWidth / Math.max(span, 0.00001));
        let wRight;
        if (u < bwFrac){
          const tt = smoothstep(0, bwFrac, u);
          wRight = tt * 0.18;
        }else if (u > 1 - bwFrac){
          const tt = smoothstep(1 - bwFrac, 1, u);
          wRight = 0.82 + tt * 0.18;
        }else{
          wRight = 0.08;
        }
        wRight = clamp01(wRight);

        const iL = left.i;
        const iR = right.i;

        const pctL = pctMap.get(participants[iL].id) || 0;
        const pctR = pctMap.get(participants[iR].id) || 0;

        const tL = clamp01(pctL / maxPct);
        const tR = clamp01(pctR / maxPct);

        const t = (1 - wRight) * tL + wRight * tR;

        const rgb = colorForDominance(t);
        const a = alphaForDominance(t);

        const pL = participants[iL];
        const pR = participants[iR];
        const cx = (1 - wRight) * pL.x + wRight * pR.x;
        const cy = (1 - wRight) * pL.y + wRight * pR.y;

        const g = heatCtx.createRadialGradient(cx, cy, circleRadius*0.06, cx, cy, circleRadius*0.78);
        g.addColorStop(0.00, `rgba(${rgb.r},${rgb.g},${rgb.b},${Math.min(0.92, a*1.15)})`);
        g.addColorStop(0.22, `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`);
        g.addColorStop(0.72, `rgba(${rgb.r},${rgb.g},${rgb.b},${a*0.10})`);
        g.addColorStop(1.00, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);

        heatCtx.fillStyle = g;

        heatCtx.beginPath();
        heatCtx.moveTo(centerX, centerY);
        heatCtx.arc(centerX, centerY, rOuter, theta, theta + dTheta, false);
        heatCtx.closePath();
        heatCtx.fill();
      }

      heatCtx.save();
      const pal = getHeatPalette();
      const baseRgb = hexToRgb(pal.secondary);
      const wash = heatCtx.createRadialGradient(centerX, centerY, circleRadius*0.40, centerX, centerY, rOuter);
      wash.addColorStop(0, `rgba(${baseRgb.r},${baseRgb.g},${baseRgb.b},0)`);
      wash.addColorStop(1, `rgba(${baseRgb.r},${baseRgb.g},${baseRgb.b},0.035)`);
      heatCtx.fillStyle = wash;
      heatCtx.beginPath();
      heatCtx.arc(centerX, centerY, rOuter, 0, Math.PI*2);
      heatCtx.fill();
      heatCtx.restore();

      unclip(heatCtx);
    }

    // ---------- CLOSE overlays on background click ----------
    notesOverlay.addEventListener('click', (e) => { if (e.target === notesOverlay) closeNotesBox(); });
    colorSchemePopup.addEventListener('click', (e) => { if (e.target === colorSchemePopup) closeColorSchemePopup(); });
    customColorPopup.addEventListener('click', (e) => { if (e.target === customColorPopup) closeCustomColorPopup(); });
    confirmRestartPopup.addEventListener('click', (e) => { if (e.target === confirmRestartPopup) closeConfirmRestartPopup(); });
    editParticipantsPopup.addEventListener('click', (e) => { if (e.target === editParticipantsPopup) closeEditParticipantsPopup(); });

    // ---------- PUBLIC API ----------
    window.startDiscussion = startDiscussion;
    window.doneAddingParticipants = doneAddingParticipants;
    window.endDiscussion = endDiscussion;
    window.pauseTimer = pauseTimer;

    window.openNotesBoxById = openNotesBoxById;
    window.saveNotes = saveNotes;
    window.closeNotesBox = closeNotesBox;

    window.openColorSchemePopup = openColorSchemePopup;
    window.closeColorSchemePopup = closeColorSchemePopup;
    window.openCustomColorPopup = openCustomColorPopup;
    window.closeCustomColorPopup = closeCustomColorPopup;
    window.updatePrimaryColorCode = updatePrimaryColorCode;
    window.updateSecondaryColorCode = updateSecondaryColorCode;
    window.applyCustomColors = applyCustomColors;

    window.switchTab = switchTab;
    window.toggleDrawer = toggleDrawer;
    window.closeDrawer = closeDrawer;

    window.copyLog = copyLog;
    window.copyReport = copyReport;
    window.copyBoth = copyBoth;

    window.confirmRestartDiscussion = confirmRestartDiscussion;
    window.closeConfirmRestartPopup = closeConfirmRestartPopup;
    window.restartDiscussion = restartDiscussion;

    window.openEditParticipantsPopup = openEditParticipantsPopup;
    window.closeEditParticipantsPopup = closeEditParticipantsPopup;
    window.addNewParticipant = addNewParticipant;
    window.openReorderParticipants = openReorderParticipants;
    window.saveReorderedParticipants = saveReorderedParticipants;
    window.openRenameParticipants = openRenameParticipants;
    window.renameParticipant = renameParticipant;
    window.saveRenamedParticipants = saveRenamedParticipants;

    window.exportScreenshot = exportScreenshot;

    window.replayDiscussion = replayDiscussion;
    window.replayDiscussionTimed = replayDiscussionTimed;

    window.generateReport = generateReport;

    window.showHeatmap = showHeatmap;
    window.hideHeatmap = hideHeatmap;
  </script>
</body>
</html>
