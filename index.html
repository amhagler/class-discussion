<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discussion Tracker</title>
  <style>
    :root{
      --primary-color:#6F263D;
      --primary-color-dark:#5c1f32;
      --secondary-color:#236192;
      --secondary-color-dark:#1b4e6f;
      --text-color:#FFFFFF;

      --bg:#f4f4f9;
      --panel:#ffffffcc;
      --panel-strong:#ffffff;
      --ink:#1f2328;
      --muted:#6b7280;

      --shadow: 0 10px 30px rgba(0,0,0,.12);
      --shadow-sm: 0 6px 18px rgba(0,0,0,.10);
      --radius: 18px;

      --pill-w: 118px;
      --pill-h: 56px;
      --pill-pad: 10px;

      /* dynamic gap (JS will set this on .stage) */
      --stage-gap-base: 28px;
      --stage-gap-dynamic: 0px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: Arial, sans-serif;
      background: radial-gradient(1200px 700px at 10% 10%, #fff, var(--bg));
      color: var(--ink);
    }

    /* Top bar */
    .topbar{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(255,255,255,.85), rgba(255,255,255,.65));
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    .topbar-inner{
      max-width: 1200px;
      margin: 0 auto;
      padding: 12px 16px;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      justify-content:space-between;
    }
    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width: 260px;
    }
    .brand h1{
      margin:0;
      font-size: 20px;
      letter-spacing:.2px;
      color: var(--primary-color);
    }
    .brand .sub{
      font-size:12px;
      color: var(--muted);
      font-weight: 300;
    }

    .controls{
      display:flex;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
      justify-content:flex-end;
    }

    .btn{
      border: none;
      background: var(--primary-color);
      color: var(--text-color);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: 0 2px 0 rgba(0,0,0,.18);
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease, opacity .2s ease;
      user-select:none;
      font-size: 14px;
      line-height: 1;
      white-space: nowrap;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,.14); background: var(--primary-color-dark); }
    .btn:active{ transform: translateY(0px); box-shadow: 0 2px 0 rgba(0,0,0,.18); }
    .btn.secondary{ background: var(--secondary-color); }
    .btn.secondary:hover{ background: var(--secondary-color-dark); }
    .btn.ghost{
      background: rgba(255,255,255,.65);
      color: var(--primary-color);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow:none;
    }
    .btn.ghost:hover{
      background: rgba(255,255,255,.9);
      box-shadow: 0 10px 24px rgba(0,0,0,.10);
      transform: translateY(-1px);
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      transform:none !important;
      box-shadow:none !important;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      height: 18px;
      padding: 0 6px;
      border-radius: 999px;
      background: rgba(255,255,255,.25);
      border: 1px solid rgba(255,255,255,.35);
      font-size: 12px;
      font-weight: 700;
      line-height: 1;
    }

    /* Main layout */
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 16px 120px;
      position: relative;
    }

    /* Title/date ABOVE circle, clearly separated */
    .title-area{
      width: 100%;
      text-align:center;
      margin: 10px 0 46px; /* more bottom space */
      padding-bottom: 10px; /* extra separation */
    }
    #discussionTitleDisplay{
      font-size: 28px;
      color: var(--primary-color);
      margin: 0;
      font-weight: 800;
      letter-spacing:.2px;
      line-height: 1.15;
    }
    #discussionDateDisplay{
      font-size: 14px;
      margin-top: 10px;
      color: var(--muted);
      font-weight: 300;
    }

    /* Setup panels */
    .setup-card{
      width: min(820px, 96%);
      margin: 0 auto 18px;
      background: var(--panel);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      backdrop-filter: blur(12px);
      padding: 14px;
    }
    .setup-row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
    }
    label{ font-size: 13px; color: var(--muted); font-weight: 300; }
    input[type="text"]{
      padding: 12px 12px;
      font-size: 16px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.14);
      outline:none;
      width: min(520px, 92vw);
      background: rgba(255,255,255,.85);
    }
    input[type="text"]:focus{
      border-color: rgba(35,97,146,.55);
      box-shadow: 0 0 0 4px rgba(35,97,146,.10);
    }
    .tiny-note{
      font-size: 12px;
      color: var(--muted);
      font-weight: 300;
      margin-top: 8px;
      text-align:center;
    }

    /* Circle + canvas */
    .stage{
      display:flex;
      justify-content:center;
      margin-top: calc(var(--stage-gap-base) + var(--stage-gap-dynamic));
    }
    #circle{
      position: relative;
      width: 860px;
      height: 860px;
      border-radius: 50%;
      border: 2px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.78);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow: visible;
    }

    /* Heatmap canvas under connection lines, above background */
    #heatCanvas{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      border-radius: 50%;
    }

    canvas#connectionCanvas{
      position:absolute;
      inset:0;
      z-index:1;
      pointer-events:none;
    }

    /* Center overlay inside circle */
    .centerOverlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 5;
      pointer-events:none;
    }
    .centerOverlay > *{ pointer-events:auto; }

    .nowSpeaking{
      position:absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 6;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(0,0,0,.10);
      color: var(--muted);
      font-size: 12px;
      font-weight: 300;
      backdrop-filter: blur(10px);
    }
    .nowSpeaking strong{
      color: var(--secondary-color);
      font-weight: 700;
    }

    /* Pause button centered, circular */
    .pause-center{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      z-index: 4;
      pointer-events:auto;
    }
    .pause-center.hidden{ display:none; }
    .pause-circle{
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.72);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-sm);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      user-select:none;
    }
    .pause-circle:hover{
      transform: scale(1.03);
      box-shadow: 0 14px 32px rgba(0,0,0,.16);
      background: rgba(255,255,255,.86);
    }
    .pause-icon{
      font-size: 22px;
      color: var(--primary-color);
      line-height: 1;
      font-weight: 800;
    }

    /* Participants */
    .participant{
      position:absolute;
      transform: translate(-50%, -50%);
      z-index: 10;
      text-align:center;
      width: var(--pill-w);
    }

    .pill{
      width: var(--pill-w);
      height: var(--pill-h);
      border-radius: 999px;
      padding: var(--pill-pad);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 3px;

      background: linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.10));
      border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      backdrop-filter: blur(10px);

      background-color: var(--primary-color);
      color: var(--text-color);
      transition: transform .14s ease, box-shadow .14s ease, background-color .18s ease, filter .18s ease;
      will-change: transform;
      cursor: pointer; /* clickable to Speak */
      user-select:none;
    }

    .pill .count{
      font-size: 12px;
      font-weight: 700;
      opacity: .95;
      line-height: 1;
    }
    .pill .name{
      font-size: 16px;
      font-weight: 800;
      line-height: 1.05;
      letter-spacing:.2px;
      max-width: 100%;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      pointer-events:none;
    }

    .pill.active{
      background-color: var(--secondary-color);
      filter: saturate(1.05);
      transform: translateY(-1px) scale(1.03);
      box-shadow: 0 16px 34px rgba(0,0,0,.16);
    }
    .pill.pulse{ animation: microPulse .26s ease-out; }
    @keyframes microPulse{
      0%{ transform: translateY(-1px) scale(1.00); }
      60%{ transform: translateY(-2px) scale(1.05); }
      100%{ transform: translateY(-1px) scale(1.03); }
    }

    /* Percentage display OUTSIDE pill (only when heatmap active) */
    .pct-out{
      display:none;
      margin-top: 6px;
      font-size: 12px;
      font-weight: 800;
      color: rgba(31,35,40,.78);
      background: rgba(255,255,255,.70);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 999px;
      padding: 6px 8px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 20px rgba(0,0,0,.10);
    }
    .pct-out.show{ display:inline-flex; }

    .pbtn-row{
      display:flex;
      gap:8px;
      justify-content:center;
      margin-top: 8px;
    }
    .pbtn{
      padding: 7px 10px;
      border-radius: 12px;
      border: none;
      cursor:pointer;
      font-size: 12px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow: 0 2px 0 rgba(0,0,0,.14);
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      user-select:none;
    }
    .pbtn:hover{ transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,.14); }
    .pbtn:active{ transform: translateY(0px); box-shadow: 0 2px 0 rgba(0,0,0,.14); }
    .pbtn.speak{ background: rgba(0,0,0,.06); color: var(--ink); border: 1px solid rgba(0,0,0,.10); }
    .pbtn.speak:hover{ background: rgba(35,97,146,.10); }
    .pbtn.notes{ background: var(--secondary-color); color: var(--text-color); }

    /* Rating box centered INSIDE circle */
    .modal-card{
      width: min(440px, 86vw);
      background: rgba(255,255,255,.86);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      padding: 14px;
    }
    .modal-card h2{
      margin: 0 0 10px;
      color: var(--primary-color);
      font-size: 18px;
    }
    .rating-options{
      display:flex;
      gap:10px;
      justify-content:center;
      margin: 10px 0 12px;
    }
    .rating-option{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.10);
      transition: transform .12s ease, background .2s ease;
      user-select:none;
      font-weight: 800;
      color: var(--ink);
    }
    .rating-option:hover{ transform: translateY(-1px); background: rgba(0,0,0,.12); }
    .rating-option.selected{
      background: var(--primary-color);
      color: var(--text-color);
      border-color: rgba(0,0,0,.0);
    }
    textarea{
      width: 100%;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.14);
      padding: 10px 12px;
      font-size: 14px;
      outline:none;
      background: rgba(255,255,255,.90);
      resize: vertical;
    }
    textarea:focus{
      border-color: rgba(35,97,146,.55);
      box-shadow: 0 0 0 4px rgba(35,97,146,.10);
    }

    /* Overlays */
    #colorSchemePopup,
    #customColorPopup,
    #confirmRestartPopup,
    #editParticipantsPopup,
    #notesBox{
      display:none;
      position:fixed;
      inset:0;
      z-index: 200;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .popup{
      width: min(920px, 94vw);
      max-height: 86vh;
      overflow:auto;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .popup h2{
      margin: 0 0 10px;
      color: var(--primary-color);
      font-size: 18px;
    }

    #colorSchemeList{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:10px;
      padding:0;
      margin:0;
      list-style:none;
    }

    /* ‚úÖ Replay Dock (side, attractive) */
    #replayDock{
      display:none;
      position: fixed;
      right: 18px;
      top: 124px;
      z-index: 120;
      width: 260px;
      border-radius: 20px;
      background: rgba(255,255,255,.88);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 16px 44px rgba(0,0,0,.18);
      padding: 12px;
    }
    #replayDock .dock-title{
      margin: 0 0 8px;
      font-size: 14px;
      font-weight: 800;
      color: var(--primary-color);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    #replayDock .dock-sub{
      margin: 10px 0 8px;
      font-size: 12px;
      font-weight: 300;
      color: var(--muted);
    }
    #replayDock .dock-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    #replayDock .dock-btn{
      flex: 1 1 30%;
      justify-content:center;
      padding: 10px 10px;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(0,0,0,.04);
      color: var(--ink);
      font-weight: 800;
      cursor:pointer;
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      box-shadow: 0 2px 0 rgba(0,0,0,.10);
    }
    #replayDock .dock-btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(0,0,0,.14);
      background: rgba(35,97,146,.10);
    }
    #replayDock .dock-btn.primaryish{
      background: rgba(111,38,61,.08);
    }
    #replayDock .dock-btn.primaryish:hover{
      background: rgba(111,38,61,.14);
    }

    .heat-toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      font-weight: 800;
      color: var(--muted);
      user-select:none;
    }
    .heat-dot{
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 6px 14px rgba(0,0,0,.12);
    }

    @media (max-width: 1100px){
      #replayDock{
        right: 12px;
        top: auto;
        bottom: 12px;
        width: min(520px, calc(100vw - 24px));
      }
    }

    @media (max-width: 900px){
      #circle{ width: 92vw; height: 92vw; max-width: 860px; max-height: 860px; }
      #colorSchemeList{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      :root{ --pill-w: 112px; --pill-h: 54px; }
    }

    .scheme{
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 16px;
      background: rgba(255,255,255,.70);
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .swatches{ display:flex; gap:10px; align-items:center; justify-content:flex-start; }
    .swatch{
      width: 30px; height: 30px; border-radius: 50%;
      border: 1px solid rgba(0,0,0,.10);
    }
    .scheme .team-name{ font-size: 13px; color: var(--ink); font-weight: 800; }
    .scheme .select-button{
      width: 100%;
      border:none;
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      background: var(--primary-color);
      color: var(--text-color);
      transition: transform .12s ease, box-shadow .12s ease, background .2s ease;
      box-shadow: 0 2px 0 rgba(0,0,0,.14);
    }
    .scheme .select-button:hover{
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0,0,0,.14);
      background: var(--primary-color-dark);
    }

    /* Bottom drawer */
    .drawer-backdrop{
      position: fixed;
      inset:0;
      z-index: 140;
      background: rgba(0,0,0,.22);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
    }
    .drawer-backdrop.open{ opacity: 1; pointer-events: auto; }

    .drawer{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 0;
      z-index: 150;
      width: min(1200px, 100%);
      border-radius: 22px 22px 0 0;
      background: rgba(255,255,255,.90);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 -14px 40px rgba(0,0,0,.18);
      max-height: 78vh;
      height: 48vh;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      translate: 0 105%;
      transition: translate .22s ease;
    }
    .drawer.open{ translate: 0 0; }

    .drawer-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    .handle{
      width: 44px;
      height: 5px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      margin: 0 auto;
    }
    .tabs{ display:flex; align-items:center; gap:8px; }
    .tab{
      border:none;
      cursor:pointer;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.06);
      color: var(--ink);
      font-weight: 800;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: transform .12s ease, background .2s ease;
    }
    .tab:hover{ transform: translateY(-1px); background: rgba(0,0,0,.10); }
    .tab.active{ background: var(--secondary-color); color: var(--text-color); }

    .drawer-actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .drawer-body{ padding: 10px 12px 12px; overflow:auto; }

    table{
      width: 100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.95);
    }
    thead th{
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, var(--primary-color), var(--primary-color-dark));
      color: var(--text-color);
      font-weight: 800;
      font-size: 13px;
      text-align:left;
      padding: 10px;
      z-index: 1;
    }
    tbody td{
      padding: 10px;
      border-top: 1px solid rgba(0,0,0,.08);
      font-size: 13px;
      vertical-align: top;
    }
    tbody tr:nth-child(even) td{ background: rgba(0,0,0,.03); }

    .cell-editable{
      cursor: text;
      border-radius: 10px;
      transition: background .14s ease;
    }
    .cell-editable:hover{
      background: rgba(35,97,146,.08);
    }
    .cell-input,
    .cell-select{
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,.14);
      padding: 8px 10px;
      font-size: 13px;
      background: rgba(255,255,255,.96);
      outline: none;
    }
    .cell-input:focus,
    .cell-select:focus{
      border-color: rgba(35,97,146,.55);
      box-shadow: 0 0 0 4px rgba(35,97,146,.10);
    }

    .section-title{
      margin: 10px 0 8px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 300;
    }

    .mini-popup{
      width: min(520px, 94vw);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 14px;
      position: relative;
    }
    .mini-popup h2{ margin:0 0 10px; color: var(--primary-color); font-size:18px; }
    .mini-actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    .close-x{
      position:absolute;
      top: 16px;
      right: 18px;
      background: transparent;
      border: none;
      cursor:pointer;
      font-size: 22px;
      color: rgba(0,0,0,.55);
    }

    /* Print tweaks */
    @media print{
      .topbar,
      #replayDock,
      #drawerBackdrop,
      #drawer,
      #discussionDetails,
      #participantFormWrap,
      #colorSchemePopup,
      #customColorPopup,
      #confirmRestartPopup,
      #editParticipantsPopup,
      #notesBox{
        display:none !important;
      }
      body{ background: #fff !important; }
      .wrap{ padding: 12px 12px 12px !important; }
      #circle{
        box-shadow:none !important;
        border: 1px solid rgba(0,0,0,.25) !important;
        background:#fff !important;
      }
      .title-area{ margin: 0 0 12px !important; padding-bottom: 0 !important; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <h1>Discussion Tracker</h1>
        <div class="sub">live facilitation + post-discussion analysis</div>
      </div>

      <div class="controls">
        <button id="endDiscussionButton" class="btn secondary" style="display:none;" onclick="endDiscussion()">
          ‚èπ End
        </button>

        <button id="toggleDrawerButton" class="btn ghost" onclick="toggleDrawer()">
          ‚ò∞ Open Panel
        </button>

        <button id="copyBothButton" class="btn" style="display:none;" onclick="copyBoth()">
          ‚ßâ Copy Both
        </button>

        <button id="restartDiscussionButton" class="btn" style="display:none;" onclick="confirmRestartDiscussion()">
          ‚Üª Restart
        </button>

        <button id="generateReportButton" class="btn secondary" style="display:none;" onclick="generateReport()">
          ‚ú® Generate Report
        </button>

        <button id="colorSchemeButton" class="btn ghost" onclick="openColorSchemePopup()">
          üé® Colors
        </button>

        <button id="editParticipantsButton" class="btn ghost" style="display:none;" onclick="openEditParticipantsPopup()">
          üë• Participants
        </button>

        <button id="exportScreenshotButton" class="btn ghost" style="display:none;" onclick="exportScreenshot()">
          üì∑ Screenshot / Print
        </button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- Title/date live ABOVE circle -->
    <div class="title-area" id="titleArea">
      <div id="discussionTitleDisplay"></div>
      <div id="discussionDateDisplay"></div>
    </div>

    <div id="discussionDetails" class="setup-card">
      <div class="setup-row">
        <label for="discussionTitle">Discussion Title:</label>
        <input type="text" id="discussionTitle" placeholder="e.g., Arab Spring Seminar (B Block)" required />
        <button class="btn secondary" onclick="startDiscussion()">‚ñ∂ Start</button>
      </div>
      <div class="tiny-note">
        Tip: Enter starts. Later, click a pill to record speaking. Speak button remains as backup.
      </div>
    </div>

    <div id="participantFormWrap" class="setup-card" style="display:none;">
      <form id="participantForm">
        <div class="setup-row">
          <label for="name">Participant Name:</label>
          <input type="text" id="name" placeholder="Add a student..." required />
          <button class="btn" type="submit">Ôºã Add</button>
          <button class="btn secondary" type="button" onclick="doneAddingParticipants()">‚úì Done</button>
        </div>
      </form>
      <div class="tiny-note">
        Duplicate names will prompt: ‚ÄúAlready exists. Add anyway?‚Äù (You can still force it.)
      </div>
    </div>

    <div class="stage" id="stage">
      <div id="circle">
        <!-- Heatmap layer (under lines) -->
        <canvas id="heatCanvas" width="860" height="860"></canvas>

        <!-- Connection lines layer (above heatmap) -->
        <canvas id="connectionCanvas" width="860" height="860"></canvas>

        <div class="nowSpeaking" id="nowSpeaking" style="display:none;">
          Now speaking: <strong id="nowSpeakingName"></strong>
        </div>

        <!-- Centered pause button -->
        <div id="pauseCenter" class="pause-center">
          <button class="pause-circle" title="Pause (ends current speaking segment)" onclick="pauseTimer()">
            <span class="pause-icon">‚è∏</span>
          </button>
        </div>

        <div class="centerOverlay">
          <div id="ratingBox" class="modal-card" style="display:none;">
            <h2>Rate Contribution</h2>
            <div class="rating-options">
              <div class="rating-option" onclick="selectRating(1)">1</div>
              <div class="rating-option" onclick="selectRating(2)">2</div>
              <div class="rating-option" onclick="selectRating(3)">3</div>
              <div class="rating-option" onclick="selectRating(4)">4</div>
              <div class="rating-option" onclick="selectRating(5)">5</div>
            </div>
            <label for="comment">Comment:</label>
            <textarea id="comment" rows="3" placeholder="Optional quick note..."></textarea>
            <div style="display:flex;justify-content:flex-end;margin-top:10px;">
              <button class="btn secondary" onclick="startTimer()">‚úÖ Save</button>
            </div>
            <div style="margin-top:8px;color:var(--muted);font-size:12px;font-weight:300;">
              Tip: Ctrl+Enter saves. Keys 1‚Äì5 select rating.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ‚úÖ Side Replay Dock -->
    <div id="replayDock" aria-hidden="true">
      <div class="dock-title">
        <span>Replay</span>
        <span class="heat-toggle" id="heatStatus">
          <span class="heat-dot"></span>
          <span id="heatStatusText">Heatmap: off</span>
        </span>
      </div>

      <div class="dock-sub">Order Replay</div>
      <div class="dock-row">
        <button class="dock-btn" onclick="replayDiscussion(2)">2√ó</button>
        <button class="dock-btn" onclick="replayDiscussion(4)">4√ó</button>
        <button class="dock-btn" onclick="replayDiscussion(8)">8√ó</button>
      </div>

      <div class="dock-sub">Timed Replay</div>
      <div class="dock-row">
        <button class="dock-btn" onclick="replayDiscussionTimed(8)">8√ó</button>
        <button class="dock-btn" onclick="replayDiscussionTimed(16)">16√ó</button>
        <button class="dock-btn" onclick="replayDiscussionTimed(32)">32√ó</button>
      </div>

      <div class="dock-sub">Heatmap</div>
      <div class="dock-row">
        <button class="dock-btn primaryish" onclick="showHeatmap()">Show</button>
        <button class="dock-btn" onclick="hideHeatmap()">Hide</button>
      </div>
    </div>
  </div>

  <!-- Drawer -->
  <div id="drawerBackdrop" class="drawer-backdrop" onclick="closeDrawer()"></div>

  <div id="drawer" class="drawer" aria-hidden="true">
    <div class="drawer-header">
      <div style="display:flex;flex-direction:column;gap:6px;min-width: 180px;">
        <div class="handle"></div>
        <div class="tabs">
          <button id="tabLog" class="tab active" onclick="switchTab('log')">
            Log <span id="logCount" class="badge">0</span>
          </button>
          <button id="tabReport" class="tab" onclick="switchTab('report')" disabled>
            Report <span id="reportReady" class="badge">‚Äî</span>
          </button>
        </div>
      </div>

      <div class="drawer-actions">
        <button id="copyLogButton" class="btn" style="display:none;" onclick="copyLog()">‚ßâ Copy Log</button>
        <button id="copyReportButton" class="btn" style="display:none;" onclick="copyReport()">‚ßâ Copy Report</button>
        <button id="drawerCloseButton" class="btn ghost" onclick="closeDrawer()">‚úï Close</button>
      </div>
    </div>

    <div class="drawer-body">
      <div id="logPanel">
        <div class="section-title">Discussion Log (click Rating or Comment to edit inline)</div>
        <table id="logTable">
          <thead>
            <tr>
              <th>Participant</th>
              <th>Timestamp</th>
              <th>Rating</th>
              <th>Comment</th>
              <th>Duration</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div id="reportPanel" style="display:none;">
        <div class="section-title">Report</div>
        <table id="reportTable">
          <thead>
            <tr>
              <th>Participant</th>
              <th>All Ratings</th>
              <th>Average</th>
              <th>Total Air Time</th>
              <th>Domination</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>

        <div class="section-title">Notes</div>
        <table id="notesReportTable">
          <thead>
            <tr>
              <th>Participant</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Popups -->
  <div id="notesBox">
    <div class="mini-popup" role="dialog" aria-modal="true">
      <h2 id="notesBoxTitle">Notes</h2>
      <textarea id="notesText" rows="5" placeholder="Quick notes..."></textarea>
      <div class="mini-actions">
        <button class="btn secondary" onclick="saveNotes()">‚úÖ Save</button>
        <button class="btn ghost" onclick="closeNotesBox()">‚úï Cancel</button>
      </div>
      <div class="tiny-note" style="text-align:left;margin-top:10px;">
        Notes are timestamped like <strong>10:14</strong>: ‚Äúkept returning to evidence‚Äù.
      </div>
    </div>
  </div>

  <div id="colorSchemePopup">
    <div class="popup">
      <h2>Color Scheme</h2>
      <ul id="colorSchemeList"></ul>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;align-items:center;">
        <label style="display:flex;align-items:center;gap:10px;">
          <input id="enableHtml2canvas" type="checkbox" />
          Enable Screenshot Capture (loads html2canvas)
        </label>
        <button class="btn ghost" onclick="closeColorSchemePopup()">‚úï Close</button>
      </div>
      <div class="tiny-note" style="text-align:left;">
        If screenshot capture is off/unavailable, Screenshot will fall back to a clean Print-to-PDF view.
      </div>
    </div>
  </div>

  <div id="customColorPopup">
    <div class="mini-popup">
      <h2>Select Your Own Colors</h2>
      <label for="primaryColor">Primary Color:</label>
      <input type="color" id="primaryColor" oninput="updatePrimaryColorCode()" style="width:100%;height:54px;border:none;background:transparent;"/>
      <div id="primaryColorCode" style="margin:8px 0;color:var(--muted);font-weight:300;">#000000</div>
      <label for="secondaryColor">Secondary Color:</label>
      <input type="color" id="secondaryColor" oninput="updateSecondaryColorCode()" style="width:100%;height:54px;border:none;background:transparent;"/>
      <div id="secondaryColorCode" style="margin:8px 0;color:var(--muted);font-weight:300;">#000000</div>
      <div class="mini-actions">
        <button class="btn secondary" onclick="applyCustomColors()">‚úÖ Apply</button>
        <button class="btn ghost" onclick="closeCustomColorPopup()">‚úï Cancel</button>
      </div>
    </div>
  </div>

  <div id="confirmRestartPopup">
    <div class="mini-popup">
      <h2>Confirmation</h2>
      <p style="margin:8px 0;color:var(--muted);font-weight:300;">This will erase all data! Are you sure you wish to proceed?</p>
      <div class="mini-actions">
        <button class="btn secondary" onclick="restartDiscussion()">Yes. I have saved my data.</button>
        <button class="btn ghost" onclick="closeConfirmRestartPopup()">No. Let me go back.</button>
      </div>
    </div>
  </div>

  <div id="editParticipantsPopup">
    <div class="popup" style="position:relative;">
      <button class="close-x" onclick="closeEditParticipantsPopup()">‚úï</button>
      <h2>Edit Participants</h2>
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <input type="text" id="newParticipantName" placeholder="Participant Name" />
        <button class="btn" onclick="addNewParticipant()">Ôºã Add</button>
        <button class="btn ghost" onclick="openReorderParticipants()">‚Üï Reorder</button>
        <button class="btn ghost" onclick="openRenameParticipants()">‚úé Rename</button>
      </div>

      <div id="reorderParticipantsContainer" style="display:none;margin-top:14px;">
        <div class="section-title">Drag to reorder</div>
        <ul id="reorderParticipantsList" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px;"></ul>
        <div style="display:flex;justify-content:flex-end;margin-top:10px;">
          <button class="btn secondary" onclick="saveReorderedParticipants()">‚úÖ Save Order</button>
        </div>
      </div>

      <div id="renameParticipantsContainer" style="display:none;margin-top:14px;">
        <div class="section-title">Rename</div>
        <ul id="renameParticipantsList" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px;"></ul>
        <div style="display:flex;justify-content:flex-end;margin-top:10px;">
          <button class="btn secondary" onclick="saveRenamedParticipants()">‚úÖ Done</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- DOM ----------
    const participantFormWrap = document.getElementById('participantFormWrap');
    const participantForm = document.getElementById('participantForm');
    const circle = document.getElementById('circle');
    const stage = document.getElementById('stage');

    const heatCanvas = document.getElementById('heatCanvas');
    const heatCtx = heatCanvas.getContext('2d');

    const canvas = document.getElementById('connectionCanvas');
    const ctx = canvas.getContext('2d');

    const ratingBox = document.getElementById('ratingBox');
    const pauseCenter = document.getElementById('pauseCenter');
    const replayDock = document.getElementById('replayDock');

    const logTableBody = document.querySelector('#logTable tbody');
    const reportTableBody = document.querySelector('#reportTable tbody');
    const notesReportTableBody = document.querySelector('#notesReportTable tbody');

    const discussionTitleDisplay = document.getElementById('discussionTitleDisplay');
    const discussionDateDisplay = document.getElementById('discussionDateDisplay');

    const nowSpeaking = document.getElementById('nowSpeaking');
    const nowSpeakingName = document.getElementById('nowSpeakingName');

    const heatStatusText = document.getElementById('heatStatusText');

    // Drawer
    const drawer = document.getElementById('drawer');
    const drawerBackdrop = document.getElementById('drawerBackdrop');
    const tabLog = document.getElementById('tabLog');
    const tabReport = document.getElementById('tabReport');
    const logPanel = document.getElementById('logPanel');
    const reportPanel = document.getElementById('reportPanel');
    const logCount = document.getElementById('logCount');
    const reportReady = document.getElementById('reportReady');

    // Buttons
    const endDiscussionButton = document.getElementById('endDiscussionButton');
    const editParticipantsButton = document.getElementById('editParticipantsButton');
    const copyLogButton = document.getElementById('copyLogButton');
    const copyReportButton = document.getElementById('copyReportButton');
    const copyBothButton = document.getElementById('copyBothButton');
    const restartDiscussionButton = document.getElementById('restartDiscussionButton');
    const generateReportButton = document.getElementById('generateReportButton');
    const exportScreenshotButton = document.getElementById('exportScreenshotButton');

    // Notes popup
    const notesOverlay = document.getElementById('notesBox');
    const notesText = document.getElementById('notesText');
    const notesBoxTitle = document.getElementById('notesBoxTitle');

    // Color scheme popup
    const colorSchemePopup = document.getElementById('colorSchemePopup');
    const colorSchemeList = document.getElementById('colorSchemeList');
    const customColorPopup = document.getElementById('customColorPopup');
    const primaryColorInput = document.getElementById('primaryColor');
    const secondaryColorInput = document.getElementById('secondaryColor');
    const primaryColorCode = document.getElementById('primaryColorCode');
    const secondaryColorCode = document.getElementById('secondaryColorCode');
    const enableHtml2canvas = document.getElementById('enableHtml2canvas');

    // Restart popup
    const confirmRestartPopup = document.getElementById('confirmRestartPopup');

    // Edit participants popup
    const editParticipantsPopup = document.getElementById('editParticipantsPopup');
    const reorderParticipantsContainer = document.getElementById('reorderParticipantsContainer');
    const reorderParticipantsList = document.getElementById('reorderParticipantsList');
    const renameParticipantsContainer = document.getElementById('renameParticipantsContainer');
    const renameParticipantsList = document.getElementById('renameParticipantsList');

    // ---------- STATE ----------
    let participants = []; // {id,name,x,y,ratings,comments,startTimes,endTimes,notes,speakCount}
    let connections = [];  // {fromId,toId,fromName,toName,thickness}
    const connectionCounts = {};
    let lastSpokenId = null;
    let currentSpeakerId = null;
    let selectedRating = null;
    let currentNotesParticipantId = null;
    let teamName = null;

    // geometry
    let circleDiameter = 860;
    let circleRadius = circleDiameter / 2;
    let centerX = circleRadius;
    let centerY = circleRadius;

    // heatmap state
    let heatmapActive = false;

    function clipToCircle(context){
      context.save();
      context.beginPath();
      context.arc(centerX, centerY, circleRadius - 2, 0, Math.PI*2);
      context.clip();
    }
    function unclip(context){ context.restore(); }

    function escapeHtml(str){
      return String(str).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }

    function uuid(){
      if (crypto && crypto.randomUUID) return crypto.randomUUID();
      // fallback
      return 'p_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
    }

    function getParticipantById(id){ return participants.find(p => p.id === id) || null; }
    function idxById(id){ return participants.findIndex(p => p.id === id); }

    // ---------- TEAMS ----------
    const nhlTeams = [
      { name: 'Anaheim Ducks', colors: ['#F47A38', '#B09862'] },
      { name: 'Boston Bruins', colors: ['#000000', '#FFB81C'] },
      { name: 'Buffalo Sabres', colors: ['#002654', '#FCB514'] },
      { name: 'Calgary Flames', colors: ['#C8102E', '#F1BE48'] },
      { name: 'Carolina Hurricanes', colors: ['#CC0000', '#A2AAAD'] },
      { name: 'Chicago Blackhawks', colors: ['#CF0A2C', '#000000'] },
      { name: 'Colorado Avalanche', colors: ['#6F263D', '#236192'] },
      { name: 'Columbus Blue Jackets', colors: ['#002654', '#CE1126'] },
      { name: 'Dallas Stars', colors: ['#006847', '#8F8F8C'] },
      { name: 'Detroit Red Wings', colors: ['#CE1126', '#FFFFFF'] },
      { name: 'Edmonton Oilers', colors: ['#041E42', '#FF4C00'] },
      { name: 'Florida Panthers', colors: ['#041E42', '#C8102E'] },
      { name: 'Los Angeles Kings', colors: ['#111111', '#A2AAAD'] },
      { name: 'Minnesota Wild', colors: ['#154734', '#A6192E'] },
      { name: 'Montreal Canadiens', colors: ['#AF1E2D', '#192168'] },
      { name: 'Nashville Predators', colors: ['#FFB81C', '#041E42'] },
      { name: 'New Jersey Devils', colors: ['#CE1126', '#000000'] },
      { name: 'New York Islanders', colors: ['#00539B', '#F47D30'] },
      { name: 'New York Rangers', colors: ['#0038A8', '#CE1126'] },
      { name: 'Ottawa Senators', colors: ['#E31837', '#C69214'] },
      { name: 'Philadelphia Flyers', colors: ['#F74902', '#000000'] },
      { name: 'Pittsburgh Penguins', colors: ['#FFB81C', '#000000'] },
      { name: 'San Jose Sharks', colors: ['#006D75', '#EA7200'] },
      { name: 'Seattle Kraken', colors: ['#001628', '#99D9D9'] },
      { name: 'St. Louis Blues', colors: ['#002F87', '#FDB827'] },
      { name: 'Tampa Bay Lightning', colors: ['#002868', '#767676'] },
      { name: 'Toronto Maple Leafs', colors: ['#00205B', '#767676'] },
      { name: 'Utah Mammoth', colors: ['#111827', '#A855F7'] },
      { name: 'Vancouver Canucks', colors: ['#001F5B', '#00843D'] },
      { name: 'Vegas Golden Knights', colors: ['#B4975A', '#333F42'] },
      { name: 'Washington Capitals', colors: ['#041E42', '#C8102E'] },
      { name: 'Winnipeg Jets', colors: ['#041E42', '#AC162C'] },
      { name: 'UCLA (Blue & Gold)', colors: ['#2774AE', '#FFD100'] }
    ];

    // ---------- COLOR SCHEME ----------
    function darkenColor(color){
      const amount = 0.2;
      const [r,g,b] = color.match(/\w\w/g).map(c => parseInt(c,16));
      return `#${Math.floor(r*(1-amount)).toString(16).padStart(2,'0')}${Math.floor(g*(1-amount)).toString(16).padStart(2,'0')}${Math.floor(b*(1-amount)).toString(16).padStart(2,'0')}`;
    }

    function isWhiteish(hex){
      const v = hex.trim().toUpperCase();
      return v === '#FFFFFF' || v === '#FFF' || v === '#FFD100';
    }
    function isBlackish(hex){
      const v = hex.trim().toUpperCase();
      return v === '#000000' || v === '#000';
    }

    function updateColorScheme(primary, secondary, team){
      document.documentElement.style.setProperty('--primary-color', primary);
      document.documentElement.style.setProperty('--primary-color-dark', darkenColor(primary));
      document.documentElement.style.setProperty('--secondary-color', secondary);
      document.documentElement.style.setProperty('--secondary-color-dark', darkenColor(secondary));
      teamName = team;

      if (secondary.toUpperCase() === '#FFFFFF' || secondary.toUpperCase() === '#FFD100') {
        document.documentElement.style.setProperty('--text-color', '#000000');
      } else {
        document.documentElement.style.setProperty('--text-color', '#FFFFFF');
      }

      if (heatmapActive){
        showHeatmap(); // re-render with new colors
      }
      redrawConnections();
    }

    function openColorSchemePopup(){ colorSchemePopup.style.display='flex'; }
    function closeColorSchemePopup(){ colorSchemePopup.style.display='none'; }
    function openCustomColorPopup(){ customColorPopup.style.display='flex'; }
    function closeCustomColorPopup(){ customColorPopup.style.display='none'; }
    function updatePrimaryColorCode(){ primaryColorCode.textContent = primaryColorInput.value; }
    function updateSecondaryColorCode(){ secondaryColorCode.textContent = secondaryColorInput.value; }
    function applyCustomColors(){
      updateColorScheme(primaryColorInput.value, secondaryColorInput.value, 'Custom');
      closeCustomColorPopup();
    }

    function createColorSchemeList(){
      colorSchemeList.innerHTML = '';
      const ucla = nhlTeams.find(t => t.name.startsWith('UCLA'));
      const coreTeams = nhlTeams.filter(t => t !== ucla);

      coreTeams.forEach(team => addSchemeCard(team));
      if (ucla) addSchemeCard(ucla);

      const li = document.createElement('li');
      li.className = 'scheme';
      li.innerHTML = `
        <div class="swatches">
          <div class="swatch" style="background:#000"></div>
          <div class="swatch" style="background:#000"></div>
        </div>
        <div class="team-name">Custom</div>
        <button class="select-button">Select your own</button>
      `;
      li.querySelector('button').onclick = () => { openCustomColorPopup(); closeColorSchemePopup(); };
      colorSchemeList.appendChild(li);

      function addSchemeCard(team){
        const li = document.createElement('li');
        li.className = 'scheme';
        li.innerHTML = `
          <div class="swatches">
            <div class="swatch" style="background:${team.colors[0]}"></div>
            <div class="swatch" style="background:${team.colors[1]}"></div>
          </div>
          <div class="team-name">${team.name}</div>
          <button class="select-button">Select</button>
        `;
        li.querySelector('button').onclick = () => {
          updateColorScheme(team.colors[0], team.colors[1], team.name);
          closeColorSchemePopup();
        };
        colorSchemeList.appendChild(li);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      createColorSchemeList();
      updateColorScheme('#6F263D','#236192','Colorado Avalanche');
    });

    // Optional html2canvas loader
    enableHtml2canvas.addEventListener('change', () => {
      if (enableHtml2canvas.checked){
        ensureHtml2canvasLoaded();
      }
    });

    function ensureHtml2canvasLoaded(){
      if (window.html2canvas) return;
      const s = document.createElement('script');
      s.src = "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
      s.async = true;
      s.onload = () => {};
      s.onerror = () => { alert("Could not load html2canvas. Screenshot will use Print-to-PDF instead."); };
      document.head.appendChild(s);
    }

    // ---------- DRAWER ----------
    function openDrawer(){
      drawer.classList.add('open');
      drawerBackdrop.classList.add('open');
      drawer.setAttribute('aria-hidden','false');
    }
    function closeDrawer(){
      drawer.classList.remove('open');
      drawerBackdrop.classList.remove('open');
      drawer.setAttribute('aria-hidden','true');
    }
    function toggleDrawer(){
      if (drawer.classList.contains('open')) closeDrawer(); else openDrawer();
    }

    function switchTab(which){
      if (which === 'log'){
        tabLog.classList.add('active');
        tabReport.classList.remove('active');
        logPanel.style.display = 'block';
        reportPanel.style.display = 'none';
        copyLogButton.style.display = 'inline-flex';
        copyReportButton.style.display = 'none';
      }else{
        tabReport.classList.add('active');
        tabLog.classList.remove('active');
        logPanel.style.display = 'none';
        reportPanel.style.display = 'block';
        copyLogButton.style.display = 'none';
        copyReportButton.style.display = 'inline-flex';
      }
      openDrawer();
    }

    // ---------- SETUP FLOW ----------
    document.getElementById('discussionTitle').addEventListener('keydown', (e) => {
      if (e.key === 'Enter'){ e.preventDefault(); startDiscussion(); }
    });

    function startDiscussion(){
      const titleInput = document.getElementById('discussionTitle').value.trim();
      if (!titleInput){ alert('Please enter a title.'); return; }

      const date = new Date().toLocaleDateString();
      discussionTitleDisplay.textContent = `${titleInput}`;
      discussionDateDisplay.textContent = `${date}`;

      document.getElementById('discussionDetails').style.display = 'none';
      participantFormWrap.style.display = 'block';
      participantForm.querySelector('#name').focus();
    }

    participantForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const nameInput = document.getElementById('name');
      const val = nameInput.value.trim();
      if (!val) return;
      if (participants.length >= 22){ alert('Maximum of 22 participants reached'); return; }

      // duplicate name warning
      const exists = participants.some(p => p.name.trim().toLowerCase() === val.toLowerCase());
      if (exists){
        const ok = confirm('Already exists. Add anyway?');
        if (!ok){ nameInput.select(); return; }
      }

      addParticipant(val);
      nameInput.value = '';
      nameInput.focus();
    });

    function addParticipant(name){
      const id = uuid();
      participants.push({
        id,
        name,
        x:0,y:0,
        ratings:[],
        comments:[],
        startTimes:[],
        endTimes:[],
        notes:[],
        speakCount:0
      });
      updateLogCount();
    }

    function doneAddingParticipants(){
      participantFormWrap.style.display = 'none';
      placeParticipants();

      endDiscussionButton.style.display = 'inline-flex';
      editParticipantsButton.style.display = 'inline-flex';
      copyLogButton.style.display = 'inline-flex';
      exportScreenshotButton.style.display = 'inline-flex';

      switchTab('log');
      closeDrawer();

      // discussion in progress => pause visible, replay hidden
      pauseCenter.style.display = 'block';
      replayDock.style.display = 'none';

      hideHeatmap(true);
    }

    // ---------- RESPONSIVE CIRCLE SIZE ----------
    function updateStageSize(){
      const max = 860;
      const min = 520;
      const avail = Math.min(window.innerWidth - 32, max);
      circleDiameter = Math.max(min, Math.min(max, avail));
      circle.style.width = circleDiameter + 'px';
      circle.style.height = circleDiameter + 'px';

      heatCanvas.width = circleDiameter;
      heatCanvas.height = circleDiameter;

      canvas.width = circleDiameter;
      canvas.height = circleDiameter;

      circleRadius = circleDiameter / 2;
      centerX = circleRadius;
      centerY = circleRadius;
    }

    // ‚úÖ Dynamic vertical clearance so top bubble never overlaps date
    function updateDynamicStageGap(){
      const any = circle.querySelector('.participant');
      if (!any){
        document.documentElement.style.setProperty('--stage-gap-dynamic', '0px');
        return;
      }
      const h = any.getBoundingClientRect().height;
      const half = h / 2;
      const extra = Math.ceil(half + 18);
      document.documentElement.style.setProperty('--stage-gap-dynamic', `${extra}px`);
    }

    window.addEventListener('resize', () => {
      updateStageSize();
      if (participants.length){
        clearParticipants();
        placeParticipants();
        redrawConnections();
        if (heatmapActive) showHeatmap();
        updateDynamicStageGap();
      }
    });
    updateStageSize();

    // ---------- PARTICIPANT PLACEMENT (on border) ----------
    function placeParticipants(){
      updateStageSize();
      const num = participants.length;
      const r = circleRadius;

      clearParticipants();

      for (let i=0;i<num;i++){
        const angle = (i / num) * (Math.PI*2) - Math.PI/2;
        const x = centerX + r * Math.cos(angle);
        const y = centerY + r * Math.sin(angle);

        const p = participants[i];

        const div = document.createElement('div');
        div.className = 'participant';
        div.dataset.pid = p.id;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.innerHTML = `
          <div id="pill${p.id}" class="pill" title="Click to record speaking">
            <div class="count" id="speakCount${p.id}">0</div>
            <div class="name" id="name${p.id}" title="${escapeHtml(p.name)}">${escapeHtml(p.name)}</div>
          </div>
          <div class="pct-out" id="pct${p.id}">0%</div>
          <div class="pbtn-row">
            <button class="pbtn speak" title="Speak (backup button)" onclick="event.stopPropagation(); recordSpeakingById('${p.id}')">üó£ Speak</button>
            <button class="pbtn notes" onclick="event.stopPropagation(); openNotesBoxById('${p.id}')">üìù Notes</button>
          </div>
        `;
        circle.appendChild(div);

        // Whole pill clickable => Speak
        div.querySelector('.pill').addEventListener('click', () => recordSpeakingById(p.id));

        p.x = x;
        p.y = y;
      }

      requestAnimationFrame(() => {
        updateDynamicStageGap();
        redrawConnections();
        if (heatmapActive) showHeatmap();
      });
    }

    function clearParticipants(){
      circle.querySelectorAll('.participant').forEach(el => el.remove());
    }

    // ---------- ONE Ctrl+Enter / ONE click SAVE ----------
    document.addEventListener('keydown', (e) => {
      const ratingOpen = ratingBox.style.display !== 'none';
      if (!ratingOpen) return;

      if (e.ctrlKey && e.key === 'Enter'){
        e.preventDefault();
        startTimer();
        return;
      }
      if (e.key >= '1' && e.key <= '5'){
        selectRating(parseInt(e.key,10));
      }
      if (e.key === 'Escape'){
        ratingBox.style.display = 'none';
        pauseCenter.classList.remove('hidden');
      }
    });

    notesOverlay.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'Enter'){ saveNotes(); }
      if (e.key === 'Escape'){ closeNotesBox(); }
    });

    // ---------- SPEAKING / LOGIC ----------
    function setNowSpeaking(id){
      if (!id){
        nowSpeaking.style.display = 'none';
        nowSpeakingName.textContent = '';
      }else{
        const p = getParticipantById(id);
        nowSpeaking.style.display = 'block';
        nowSpeakingName.textContent = p ? p.name : '';
      }
    }

    function setActivePill(activeId){
      participants.forEach((p) => {
        const pill = document.getElementById(`pill${p.id}`);
        if (!pill) return;
        pill.classList.remove('active','pulse');
        if (p.id === activeId){
          pill.classList.add('active','pulse');
        }
      });
    }

    window.recordSpeakingById = function(id){
      const index = idxById(id);
      if (index < 0) return;

      const now = new Date();
      const participant = participants[index];

      participant.speakCount += 1;
      const countEl = document.getElementById(`speakCount${participant.id}`);
      if (countEl) countEl.textContent = participant.speakCount;

      // end previous speaker if switching
      if (currentSpeakerId && currentSpeakerId !== id){
        const prev = getParticipantById(currentSpeakerId);
        if (prev && prev.startTimes.length){
          const dur = (now - prev.startTimes[prev.startTimes.length - 1]) / 1000;
          prev.endTimes.push(dur);
          updateDurationInLog(prev.id, prev.endTimes.length - 1, dur);
        }
      }

      // clicking same speaker again toggles off (end segment)
      if (currentSpeakerId && currentSpeakerId === id){
        const curr = getParticipantById(currentSpeakerId);
        if (curr && curr.startTimes.length){
          const dur = (now - curr.startTimes[curr.startTimes.length - 1]) / 1000;
          curr.endTimes.push(dur);
          updateDurationInLog(curr.id, curr.endTimes.length - 1, dur);
        }
        currentSpeakerId = null;
        setActivePill(null);
        setNowSpeaking(null);
        ratingBox.style.display = 'none';
        pauseCenter.classList.remove('hidden');
        return;
      }

      // start new segment
      currentSpeakerId = id;
      participant.startTimes.push(now);

      // create connection from last speaker to current
      if (lastSpokenId && lastSpokenId !== id){
        const from = getParticipantById(lastSpokenId);
        const to = getParticipantById(id);
        if (from && to){
          const key = `${lastSpokenId}-${id}`;
          const rkey = `${id}-${lastSpokenId}`;
          if (connectionCounts[key]) connectionCounts[key] += 1;
          else if (connectionCounts[rkey]) connectionCounts[rkey] += 1;
          else connectionCounts[key] = 1;

          const thickness = connectionCounts[key] || connectionCounts[rkey] || 1;
          connections.push({ fromId: from.id, toId: to.id, fromName: from.name, toName: to.name, thickness });
          animateConnection(from.id, to.id, thickness, 'var(--secondary-color)', 220, () => {});
        }
      }

      lastSpokenId = id;

      resetRating();
      ratingBox.style.display = 'block';
      pauseCenter.classList.add('hidden');
      document.getElementById('comment').focus();

      setActivePill(id);
      setNowSpeaking(id);

      // if heatmap is on, hide it while actively discussing (clean)
      if (heatmapActive){
        hideHeatmap(true);
      }
    };

    function selectRating(rating){
      selectedRating = rating;
      ratingBox.querySelectorAll('.rating-option').forEach(opt => opt.classList.remove('selected'));
      ratingBox.querySelectorAll('.rating-option')[rating - 1].classList.add('selected');
    }
    function resetRating(){
      selectedRating = null;
      ratingBox.querySelectorAll('.rating-option').forEach(opt => opt.classList.remove('selected'));
    }

    function startTimer(){
      if (!currentSpeakerId) return;

      ratingBox.style.display = 'none';
      pauseCenter.classList.remove('hidden');

      const participant = getParticipantById(currentSpeakerId);
      if (!participant) return;

      participant.ratings.push(selectedRating);
      participant.comments.push(document.getElementById('comment').value);

      const seq = participant.ratings.length - 1;

      const row = logTableBody.insertRow();
      row.dataset.pid = participant.id;
      row.dataset.seq = String(seq);

      row.insertCell(0).textContent = participant.name;
      row.insertCell(1).textContent = new Date().toLocaleString();

      const ratingCell = row.insertCell(2);
      ratingCell.className = 'cell-editable';
      ratingCell.textContent = selectedRating !== null ? selectedRating : '';
      ratingCell.title = 'Click to edit rating';

      const commentCell = row.insertCell(3);
      commentCell.className = 'cell-editable';
      commentCell.textContent = document.getElementById('comment').value;
      commentCell.title = 'Click to edit comment';

      row.insertCell(4).textContent = '';

      document.getElementById('comment').value = '';
      resetRating();
      updateLogCount();
    }

    function updateLogCount(){
      const rows = Array.from(logTableBody.rows);
      const contribs = rows.filter(r => r.cells[1] && r.cells[1].textContent.trim() !== '').length;
      logCount.textContent = String(contribs);
    }

    function updateDurationInLog(pid, seq, duration){
      const rows = Array.from(logTableBody.rows);
      for (let i = rows.length - 1; i >= 0; i--){
        if (rows[i].dataset.pid === pid && rows[i].dataset.seq === String(seq)){
          rows[i].cells[4].textContent = duration.toFixed(2) + "s";
          break;
        }
      }
    }

    function endDiscussion(){
      const now = new Date();
      if (currentSpeakerId){
        const curr = getParticipantById(currentSpeakerId);
        if (curr && curr.startTimes.length){
          const dur = (now - curr.startTimes[curr.startTimes.length - 1]) / 1000;
          curr.endTimes.push(dur);
          updateDurationInLog(curr.id, curr.endTimes.length - 1, dur);
        }
      }

      ratingBox.style.display = 'none';
      currentSpeakerId = null;
      setActivePill(null);
      setNowSpeaking(null);

      // When the discussion ends, hide pause button entirely
      pauseCenter.style.display = 'none';

      // Show replay dock on the side
      replayDock.style.display = 'block';
      replayDock.setAttribute('aria-hidden','false');

      copyBothButton.style.display = 'inline-flex';
      restartDiscussionButton.style.display = 'inline-flex';
      generateReportButton.style.display = 'inline-flex';
      exportScreenshotButton.style.display = 'inline-flex';

      copyLogButton.style.display = 'inline-flex';
      switchTab('log');
      openDrawer();

      // clear any stale heatmap display state
      hideHeatmap(true);
    }

    // ---------- INLINE EDITING (log table) ----------
    logTableBody.addEventListener('click', (e) => {
      const td = e.target.closest('td');
      if (!td) return;
      const tr = td.closest('tr');
      if (!tr) return;

      // Only rating/comment columns
      const colIndex = td.cellIndex;
      if (colIndex !== 2 && colIndex !== 3) return;

      if (td.querySelector('input,select,textarea')) return; // already editing

      const pid = tr.dataset.pid;
      const seq = parseInt(tr.dataset.seq || '0', 10);
      const p = getParticipantById(pid);
      if (!p) return;

      if (colIndex === 2){
        // Rating edit: select 1-5 or blank
        const current = (td.textContent || '').trim();
        const sel = document.createElement('select');
        sel.className = 'cell-select';
        const optBlank = document.createElement('option');
        optBlank.value = '';
        optBlank.textContent = '';
        sel.appendChild(optBlank);
        for (let i=1;i<=5;i++){
          const o = document.createElement('option');
          o.value = String(i);
          o.textContent = String(i);
          sel.appendChild(o);
        }
        sel.value = current;
        td.textContent = '';
        td.appendChild(sel);
        sel.focus();

        const commit = () => {
          const v = sel.value;
          td.innerHTML = '';
          td.textContent = v;
          p.ratings[seq] = v ? parseInt(v,10) : null;
        };
        sel.addEventListener('change', commit);
        sel.addEventListener('blur', commit);
        sel.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter'){ ev.preventDefault(); commit(); }
          if (ev.key === 'Escape'){ ev.preventDefault(); td.innerHTML=''; td.textContent=current; }
        });
      }else{
        // Comment edit: input
        const current = td.textContent || '';
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.className = 'cell-input';
        inp.value = current;
        td.textContent = '';
        td.appendChild(inp);
        inp.focus();
        inp.select();

        const commit = () => {
          const v = inp.value;
          td.innerHTML = '';
          td.textContent = v;
          p.comments[seq] = v;
        };
        inp.addEventListener('blur', commit);
        inp.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter'){ ev.preventDefault(); commit(); }
          if (ev.key === 'Escape'){ ev.preventDefault(); td.innerHTML=''; td.textContent=current; }
        });
      }
    });

    // ---------- LINE GEOMETRY ----------
    function getInnerAnchor(fromId, toId){
      const from = getParticipantById(fromId);
      const to = getParticipantById(toId);
      if (!from || !to) return {x1:0,y1:0,x2:0,y2:0};

      const offset = Math.max(30, Math.min(44, circleDiameter * 0.055));

      const vfx = centerX - from.x;
      const vfy = centerY - from.y;
      const vfl = Math.hypot(vfx, vfy) || 1;
      const ax1 = from.x + (vfx / vfl) * offset;
      const ay1 = from.y + (vfy / vfl) * offset;

      const vtx = centerX - to.x;
      const vty = centerY - to.y;
      const vtl = Math.hypot(vtx, vty) || 1;
      const ax2 = to.x + (vtx / vtl) * offset;
      const ay2 = to.y + (vty / vtl) * offset;

      return { x1: ax1, y1: ay1, x2: ax2, y2: ay2 };
    }

    function redrawConnections(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      clipToCircle(ctx);

      for (const c of connections){
        const { x1,y1,x2,y2 } = getInnerAnchor(c.fromId, c.toId);
        drawLineInstant(x1,y1,x2,y2,c.thickness,'var(--secondary-color)', true);
      }

      unclip(ctx);
    }

    function drawLineInstant(x1,y1,x2,y2,thickness,color,glow){
      ctx.lineWidth = thickness;
      ctx.strokeStyle = color;
      ctx.lineCap = 'round';

      if (glow){
        ctx.shadowColor = 'rgba(35,97,146,.45)';
        ctx.shadowBlur = Math.min(18, 8 + thickness * 2);
      }else{
        ctx.shadowBlur = 0;
      }

      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function animateConnection(fromId, toId, thickness, cssColor, durationMs, onDone){
      const { x1,y1,x2,y2 } = getInnerAnchor(fromId,toId);

      const color = getComputedStyle(document.documentElement)
        .getPropertyValue(cssColor.replace('var(','').replace(')','')).trim() || cssColor;

      const start = performance.now();
      const glow = true;

      function frame(t){
        const p = Math.min(1, (t - start) / durationMs);
        const ex = x1 + (x2 - x1) * p;
        const ey = y1 + (y2 - y1) * p;

        ctx.clearRect(0,0,canvas.width,canvas.height);
        clipToCircle(ctx);

        for (let i=0;i<connections.length-1;i++){
          const c = connections[i];
          const a = getInnerAnchor(c.fromId,c.toId);
          drawLineInstant(a.x1,a.y1,a.x2,a.y2,c.thickness,'var(--secondary-color)', true);
        }

        drawLineInstant(x1,y1,ex,ey,thickness,color,glow);

        unclip(ctx);

        if (p < 1) requestAnimationFrame(frame);
        else onDone && onDone();
      }
      requestAnimationFrame(frame);
    }

    // ---------- REPLAY ----------
    function highlightParticipant(id){
      setActivePill(id);
      setNowSpeaking(id);
    }

    function resetReplayCache(){ window.__replayDrawn = []; }

    function replayDiscussion(speed){
      hideHeatmap(true);
      resetReplayCache();

      ctx.clearRect(0,0,canvas.width,canvas.height);
      let i = 0;

      function step(){
        if (i >= connections.length) {
          setNowSpeaking(null);
          setActivePill(null);
          showHeatmap(); // heatmap appears at end of replay
          return;
        }

        const seg = connections[i];
        const fromId = seg.fromId;
        const toId = seg.toId;

        highlightParticipant(fromId);

        const dur = Math.max(220, 750 / speed);
        animateReplaySegment(fromId, toId, seg.thickness, dur, () => {
          highlightParticipant(toId);
          i++;
          setTimeout(step, 120);
        });
      }

      step();
    }

    function replayDiscussionTimed(speed){
      hideHeatmap(true);
      resetReplayCache();

      ctx.clearRect(0,0,canvas.width,canvas.height);
      let i = 0;

      // copy durations by participant (for pace)
      const endTimesCopy = new Map(participants.map(p => [p.id, [...p.endTimes]]));

      function step(){
        if (i >= connections.length) {
          setNowSpeaking(null);
          setActivePill(null);
          showHeatmap(); // heatmap appears at end of replay
          return;
        }

        const seg = connections[i];
        const fromId = seg.fromId;
        const toId = seg.toId;

        highlightParticipant(fromId);

        const arr = endTimesCopy.get(toId) || [];
        const durationSpoken = (arr.shift() || 1);
        endTimesCopy.set(toId, arr);

        const dur = Math.max(260, (durationSpoken / speed) * 1000);

        animateReplaySegment(fromId, toId, seg.thickness, dur, () => {
          highlightParticipant(toId);
          i++;
          setTimeout(step, 100);
        });
      }

      step();
    }

    function animateReplaySegment(fromId,toId,thickness,durationMs,onDone){
      const start = performance.now();
      const { x1,y1,x2,y2 } = getInnerAnchor(fromId,toId);

      function frame(t){
        const p = Math.min(1, (t - start) / durationMs);

        ctx.clearRect(0,0,canvas.width,canvas.height);
        clipToCircle(ctx);

        if (window.__replayDrawn == null) window.__replayDrawn = [];
        for (const seg of window.__replayDrawn){
          drawLineInstant(seg.x1,seg.y1,seg.x2,seg.y2,seg.thickness,'var(--secondary-color)', true);
        }

        const ex = x1 + (x2-x1)*p;
        const ey = y1 + (y2-y1)*p;
        drawLineInstant(x1,y1,ex,ey,thickness,'var(--secondary-color)', true);

        unclip(ctx);

        if (p < 1){
          requestAnimationFrame(frame);
        }else{
          window.__replayDrawn.push({ x1,y1,x2,y2,thickness });
          onDone && onDone();
        }
      }
      requestAnimationFrame(frame);
    }

    // ---------- REPORT ----------
    function generateReport(){
      reportTableBody.innerHTML = '';
      notesReportTableBody.innerHTML = '';

      const totalDuration = participants.reduce((sum,p) => sum + p.endTimes.reduce((a,b)=>a+b,0), 0);

      participants.forEach(p => {
        const ratings = p.ratings.filter(r => r !== null && r !== undefined && r !== '');
        const avg = ratings.length ? (ratings.reduce((a,b)=>a+b,0)/ratings.length).toFixed(2) : 'N/A';

        const air = p.endTimes.reduce((a,b)=>a+b,0);
        const minutes = Math.floor(air/60);
        const seconds = air % 60;
        const formatted = `${minutes}m ${seconds.toFixed(2)}s`;
        const domination = totalDuration > 0 ? ((air/totalDuration)*100).toFixed(2)+'%' : '0%';

        const row = reportTableBody.insertRow();
        row.insertCell(0).textContent = p.name;
        row.insertCell(1).textContent = ratings.join(', ');
        row.insertCell(2).textContent = avg;
        row.insertCell(3).textContent = formatted;
        row.insertCell(4).textContent = domination;

        const nrow = notesReportTableBody.insertRow();
        nrow.insertCell(0).textContent = p.name;
        nrow.insertCell(1).textContent = p.notes.join('\n');
      });

      tabReport.disabled = false;
      reportReady.textContent = '‚úì';

      copyReportButton.style.display = 'inline-flex';
      copyBothButton.style.display = 'inline-flex';

      switchTab('report');
      openDrawer();
    }

    // ---------- COPY ----------
    function copyNodeAsTSV(tableEl){
      const rows = Array.from(tableEl.querySelectorAll('tr'));
      const lines = rows.map(r => {
        const cells = Array.from(r.children).map(td => (td.innerText || '').replace(/\s+/g,' ').trim());
        return cells.join('\t');
      });
      return lines.join('\n');
    }

    async function copyToClipboard(text){
      try{
        await navigator.clipboard.writeText(text);
      }catch(e){
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
      }
    }

    async function copyLog(){
      const text = copyNodeAsTSV(document.getElementById('logTable'));
      await copyToClipboard(text);
      alert('Discussion log copied (TSV).');
    }

    async function copyReport(){
      const reportText = copyNodeAsTSV(document.getElementById('reportTable'));
      const notesText2 = copyNodeAsTSV(document.getElementById('notesReportTable'));
      await copyToClipboard(reportText + "\n\n" + notesText2);
      alert('Report copied (TSV).');
    }

    async function copyBoth(){
      const logText = copyNodeAsTSV(document.getElementById('logTable'));
      const reportText = copyNodeAsTSV(document.getElementById('reportTable'));
      const notesText2 = copyNodeAsTSV(document.getElementById('notesReportTable'));
      const combined =
        "REPORT\n" + reportText + "\n\nNOTES\n" + notesText2 + "\n\nLOG\n" + logText;
      await copyToClipboard(combined);
      alert('Report + Notes + Log copied (TSV).');
    }

    // ---------- NOTES (timestamped) ----------
    function openNotesBoxById(pid){
      const p = getParticipantById(pid);
      if (!p) return;
      currentNotesParticipantId = pid;
      notesBoxTitle.textContent = `Notes about ${p.name}`;
      notesText.value = '';
      notesOverlay.style.display = 'flex';
      notesText.focus();
    }
    function saveNotes(){
      const note = notesText.value.trim();
      if (currentNotesParticipantId && note){
        const p = getParticipantById(currentNotesParticipantId);
        if (p){
          const t = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
          p.notes.push(`${t}: ${note}`);
        }
      }
      closeNotesBox();
    }
    function closeNotesBox(){
      notesOverlay.style.display = 'none';
      currentNotesParticipantId = null;
    }

    // ---------- PAUSE ----------
    function pauseTimer(){
      if (currentSpeakerId){
        const now = new Date();
        const curr = getParticipantById(currentSpeakerId);
        if (curr && curr.startTimes.length){
          const dur = (now - curr.startTimes[curr.startTimes.length - 1]) / 1000;
          curr.endTimes.push(dur);
          updateDurationInLog(curr.id, curr.endTimes.length - 1, dur);
        }
        currentSpeakerId = null;
        ratingBox.style.display = 'none';
        pauseCenter.classList.remove('hidden');
        setActivePill(null);
        setNowSpeaking(null);
      }
    }

    // ---------- RESTART ----------
    function confirmRestartDiscussion(){ confirmRestartPopup.style.display = 'flex'; }
    function closeConfirmRestartPopup(){ confirmRestartPopup.style.display = 'none'; }
    function restartDiscussion(){ location.reload(); }

    // ---------- EDIT PARTICIPANTS ----------
    function openEditParticipantsPopup(){ editParticipantsPopup.style.display = 'flex'; }
    function closeEditParticipantsPopup(){
      editParticipantsPopup.style.display = 'none';
      reorderParticipantsContainer.style.display = 'none';
      renameParticipantsContainer.style.display = 'none';
    }

    function addNewParticipant(){
      const inp = document.getElementById('newParticipantName');
      const name = inp.value.trim();
      if (!name){ alert('Please enter a name.'); return; }
      if (participants.length >= 22){ alert('Maximum of 22 participants reached'); return; }

      const exists = participants.some(p => p.name.trim().toLowerCase() === name.toLowerCase());
      if (exists){
        const ok = confirm('Already exists. Add anyway?');
        if (!ok){ inp.select(); return; }
      }

      addParticipant(name);
      placeParticipants();
      redrawConnections();
      if (heatmapActive) showHeatmap();
      inp.value = '';
      closeEditParticipantsPopup();
    }

    function openReorderParticipants(){
      reorderParticipantsContainer.style.display = 'block';
      renameParticipantsContainer.style.display = 'none';
      reorderParticipantsList.innerHTML = '';

      participants.forEach((p, idx) => {
        const li = document.createElement('li');
        li.draggable = true;
        li.dataset.index = idx;
        li.style.display = 'flex';
        li.style.alignItems = 'center';
        li.style.justifyContent = 'space-between';
        li.style.padding = '10px';
        li.style.border = '1px solid rgba(0,0,0,.10)';
        li.style.borderRadius = '14px';
        li.style.background = 'rgba(255,255,255,.80)';
        li.style.cursor = 'grab';
        li.innerHTML = `<strong>${escapeHtml(p.name)}</strong><span style="color:var(--muted);font-weight:300;">drag</span>`;
        li.addEventListener('dragstart', handleDragStart);
        li.addEventListener('dragover', handleDragOver);
        li.addEventListener('drop', handleDrop);
        li.addEventListener('dragend', handleDragEnd);
        reorderParticipantsList.appendChild(li);
      });
    }

    let dragSrcEl = null;
    function handleDragStart(e){ dragSrcEl = this; this.style.opacity = '0.5'; }
    function handleDragOver(e){ e.preventDefault(); return false; }
    function handleDrop(e){
      e.stopPropagation();
      if (dragSrcEl !== this){
        const srcIndex = parseInt(dragSrcEl.dataset.index,10);
        const tgtIndex = parseInt(this.dataset.index,10);
        [participants[srcIndex], participants[tgtIndex]] = [participants[tgtIndex], participants[srcIndex]];
        openReorderParticipants();
      }
      return false;
    }
    function handleDragEnd(e){ this.style.opacity = '1'; }

    function saveReorderedParticipants(){
      placeParticipants();
      redrawConnections();
      if (heatmapActive) showHeatmap();
      reorderParticipantsContainer.style.display = 'none';
    }

    function openRenameParticipants(){
      renameParticipantsContainer.style.display = 'block';
      reorderParticipantsContainer.style.display = 'none';
      renameParticipantsList.innerHTML = '';

      participants.forEach((p, idx) => {
        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.gap = '10px';
        li.style.alignItems = 'center';
        li.innerHTML = `
          <input type="text" id="renameInput${idx}" value="${escapeHtml(p.name)}" />
          <button class="btn secondary" type="button" onclick="renameParticipant(${idx})">Save</button>
        `;
        renameParticipantsList.appendChild(li);
      });
    }

    function renameParticipant(index){
      const inp = document.getElementById(`renameInput${index}`);
      const newName = inp.value.trim();
      if (!newName){ alert('Please enter a valid name.'); return; }

      // duplicate warning (but allow)
      const exists = participants.some((p,i) => i !== index && p.name.trim().toLowerCase() === newName.toLowerCase());
      if (exists){
        const ok = confirm('Already exists. Rename anyway?');
        if (!ok){ inp.select(); return; }
      }

      const p = participants[index];
      p.name = newName;

      // update pill text + title
      const nameEl = document.getElementById(`name${p.id}`);
      if (nameEl){
        nameEl.textContent = newName;
        nameEl.title = newName;
      }

      // update log table participant name cells by pid
      Array.from(logTableBody.rows).forEach(r => {
        if (r.dataset.pid === p.id){
          r.cells[0].textContent = newName;
        }
      });

      // update notes popup title if open
      if (currentNotesParticipantId === p.id){
        notesBoxTitle.textContent = `Notes about ${p.name}`;
      }

      redrawConnections();
      if (heatmapActive) showHeatmap();
      updateLogCount();
    }

    function saveRenamedParticipants(){
      renameParticipantsContainer.style.display = 'none';
      closeEditParticipantsPopup();
    }

    // ---------- SCREENSHOT / PRINT ----------
    async function exportScreenshot(){
      // Prefer html2canvas when available; otherwise print
      if (window.html2canvas){
        try{
          // hide drawer for capture (looks cleaner)
          const drawerWasOpen = drawer.classList.contains('open');
          closeDrawer();

          const target = document.querySelector('.wrap');
          const canvasShot = await window.html2canvas(target, {
            backgroundColor: "#ffffff",
            scale: 2,
            useCORS: true
          });

          // restore drawer state
          if (drawerWasOpen) openDrawer();

          const dataUrl = canvasShot.toDataURL("image/png");
          const w = window.open('', '_blank');
          if (!w){ alert('Popup blocked. Allow popups to export screenshot.'); return; }
          w.document.write(`
            <title>Discussion Tracker Screenshot</title>
            <style>body{margin:0;background:#111;display:flex;align-items:center;justify-content:center;min-height:100vh;} img{max-width:100%;height:auto;}</style>
            <img src="${dataUrl}" alt="Screenshot" />
          `);
          w.document.close();
          return;
        }catch(err){
          alert('Screenshot capture failed. Falling back to Print-to-PDF.');
        }
      }

      // Print fallback
      window.print();
    }

    // ---------- HEATMAP (Bold, differentiated, rim-weighted, angular blending) ----------
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function smoothstep(a,b,x){
      const t = clamp01((x-a)/(b-a));
      return t*t*(3-2*t);
    }

    function hexToRgb(hex){
      const h = hex.trim().replace('#','');
      if (h.length === 3){
        const r = parseInt(h[0]+h[0],16);
        const g = parseInt(h[1]+h[1],16);
        const b = parseInt(h[2]+h[2],16);
        return {r,g,b};
      }
      const r = parseInt(h.slice(0,2),16);
      const g = parseInt(h.slice(2,4),16);
      const b = parseInt(h.slice(4,6),16);
      return {r,g,b};
    }

    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      let h, s, l = (max+min)/2;
      if (max === min){ h = s = 0; }
      else{
        const d = max-min;
        s = l > 0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h = (g-b)/d + (g<b ? 6 : 0); break;
          case g: h = (b-r)/d + 2; break;
          case b: h = (r-g)/d + 4; break;
        }
        h /= 6;
      }
      return {h,s,l};
    }

    function hslToRgb(h,s,l){
      let r,g,b;
      if (s === 0){ r = g = b = l; }
      else{
        const hue2rgb = (p,q,t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q-p)*6*t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q-p)*(2/3 - t)*6;
          return p;
        };
        const q = l < 0.5 ? l*(1+s) : l + s - l*s;
        const p = 2*l - q;
        r = hue2rgb(p,q,h+1/3);
        g = hue2rgb(p,q,h);
        b = hue2rgb(p,q,h-1/3);
      }
      return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)};
    }

    function mixRgb(a,b,t){
      return {
        r: Math.round(a.r + (b.r - a.r) * t),
        g: Math.round(a.g + (b.g - a.g) * t),
        b: Math.round(a.b + (b.b - a.b) * t)
      };
    }

    // "Exact knobs" idea:
    // - Nonlinear dominance curve for color + alpha (more differentiation)
    // - Separate blend (secondary->primary) from intensity (alpha)
    // - Saturation boost increases with dominance (bolder)
    function dominanceCurve(t){
      // A: gamma < 1 boosts mid/high separation
      const gamma = 0.60;
      return Math.pow(clamp01(t), gamma);
    }
    function intensityCurve(t){
      // Slightly stronger than color curve: makes dominance pop
      const gamma = 0.52;
      return Math.pow(clamp01(t), gamma);
    }

    function getHeatPalette(){
      const cs = getComputedStyle(document.documentElement);
      const primary = cs.getPropertyValue('--primary-color').trim() || '#6F263D';
      const secondary = cs.getPropertyValue('--secondary-color').trim() || '#236192';

      // if one is white-ish or black-ish, use gray spectrum instead
      if (isWhiteish(primary) || isWhiteish(secondary)){
        return { primary: '#9CA3AF', secondary: '#E5E7EB', mode: 'gray-light' };
      }
      if (isBlackish(primary) || isBlackish(secondary)){
        return { primary: '#111827', secondary: '#6B7280', mode: 'gray-dark' };
      }
      return { primary, secondary, mode: 'team' };
    }

    function colorForDominance(tNorm){
      const pal = getHeatPalette();
      const pRgb = hexToRgb(pal.primary);
      const sRgb = hexToRgb(pal.secondary);

      // baseline faint presence even near 0:
      const baselineBlend = 0.10; // keeps a faint spectrum baseline (your "near 0 faint baseline")
      const tColor = dominanceCurve(tNorm);

      const blend = baselineBlend + (1 - baselineBlend) * tColor; // higher => closer to primary
      let rgb = mixRgb(sRgb, pRgb, clamp01(blend));

      // Saturation boost for boldness (stronger as dominance increases)
      // For grays, this does little; for team colors, it punches.
      const satBoostBase = 1.10;
      const satBoostMax = 1.55;
      const satBoost = satBoostBase + (satBoostMax - satBoostBase) * tColor;

      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      hsl.s = clamp01(hsl.s * satBoost);
      // Also nudge lightness slightly to avoid "muddy mid":
      const lNudge = (tColor - 0.5) * 0.08; // subtle
      hsl.l = clamp01(hsl.l + lNudge);

      rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
      return rgb;
    }

    function alphaForDominance(tNorm){
      // baseline + nonlinear alpha curve
      const base = 0.06;   // faint wash at near 0
      const max = 0.62;    // bold
      const tA = intensityCurve(tNorm);
      return base + (max - base) * tA;
    }

    function computeDominationPercents(){
      const total = participants.reduce((sum,p) => sum + p.endTimes.reduce((a,b)=>a+b,0), 0);
      const arr = participants.map(p => {
        const air = p.endTimes.reduce((a,b)=>a+b,0);
        const pct = total > 0 ? (air/total)*100 : 0;
        return { id:p.id, pct };
      });
      const maxPct = arr.reduce((m,o)=>Math.max(m,o.pct), 0) || 0.00001;
      return { arr, total, maxPct };
    }

    function angleOfPoint(x,y){
      return Math.atan2(y - centerY, x - centerX); // -pi..pi
    }

    function normalizeAngle(a){
      let x = a;
      while (x < 0) x += Math.PI*2;
      while (x >= Math.PI*2) x -= Math.PI*2;
      return x;
    }

    function showHeatmap(){
      if (!participants.length) return;

      heatmapActive = true;
      heatStatusText.textContent = 'Heatmap: on';

      // show pct badges outside pills
      const { arr, maxPct } = computeDominationPercents();
      const pctMap = new Map(arr.map(o => [o.id, o.pct]));

      participants.forEach(p => {
        const el = document.getElementById(`pct${p.id}`);
        if (el){
          const pct = pctMap.get(p.id) || 0;
          el.textContent = `${pct.toFixed(1)}%`;
          el.classList.add('show');
        }
      });

      // render heatmap
      renderHeatmapAngularBlended(maxPct, pctMap);
    }

    function hideHeatmap(silent){
      heatmapActive = false;
      heatStatusText.textContent = 'Heatmap: off';
      heatCtx.clearRect(0,0,heatCanvas.width,heatCanvas.height);

      // hide pct badges
      participants.forEach(p => {
        const el = document.getElementById(`pct${p.id}`);
        if (el) el.classList.remove('show');
      });

      if (!silent) redrawConnections();
    }

    function renderHeatmapAngularBlended(maxPct, pctMap){
      heatCtx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
      clipToCircle(heatCtx);

      const num = participants.length;
      if (num === 0){
        unclip(heatCtx);
        return;
      }

      // Precompute participant angles around the circle (based on layout)
      const angles = participants.map(p => normalizeAngle(angleOfPoint(p.x, p.y)));

      // We'll sample around the circle and paint thin wedges.
      // Higher samples => smoother boundaries.
      const steps = Math.max(720, num * 180); // adaptive
      const dTheta = (Math.PI*2) / steps;

      // Boundary blend width (radians): smoother transitions between sectors
      const boundaryWidth = Math.max(0.10, Math.min(0.22, (Math.PI*2)/(num*3))); // ~6-12 degrees typical

      // Rim weighting: strongest near rim and especially near pills
      const rInner = circleRadius * 0.08;
      const rOuter = circleRadius - 2;

      // Helper to find closest two participant indices for a given angle on the ring ordering
      // We assume participants are placed in array order around circle; angles should be monotonic-ish
      // We'll sort by angle, then locate interval.
      const sorted = participants
        .map((p,i)=>({i, a: angles[i]}))
        .sort((x,y)=>x.a - y.a);

      function findBracket(theta){
        // theta normalized 0..2pi
        // find last sorted angle <= theta
        let lo = 0, hi = sorted.length - 1;
        while (lo <= hi){
          const mid = (lo + hi) >> 1;
          if (sorted[mid].a <= theta) lo = mid + 1;
          else hi = mid - 1;
        }
        const rightIdx = lo % sorted.length;            // first angle > theta (wrap)
        const leftIdx = (rightIdx - 1 + sorted.length) % sorted.length;
        return { left: sorted[leftIdx], right: sorted[rightIdx] };
      }

      // Convert to continuous distance between angles on the circle
      function angleDist(a,b){
        let d = Math.abs(a-b);
        if (d > Math.PI) d = Math.PI*2 - d;
        return d;
      }

      // Draw each wedge slice with a radial gradient (rim-weighted), using blended color+alpha.
      for (let s=0; s<steps; s++){
        const theta = s * dTheta; // 0..2pi
        const mid = theta + dTheta/2;

        const { left, right } = findBracket(mid);
        const aL = left.a;
        const aR = right.a;

        // compute interpolation parameter along the arc from left->right (handle wrap)
        let span = aR - aL;
        if (span < 0) span += Math.PI*2;
        let along = mid - aL;
        if (along < 0) along += Math.PI*2;
        const u = span > 0 ? along / span : 0;

        // boundary blending: emphasize smoothness near ends
        // We want the "middle" of the sector to be clearly that participant, and
        // the boundary region to blend.
        // We'll define weight of right side using a smoothstep around the boundaryWidth.
        // Convert boundaryWidth to fraction of span:
        const bwFrac = Math.min(0.45, boundaryWidth / Math.max(span, 0.00001));
        let wRight;
        if (u < bwFrac){
          // near left boundary => mostly left
          wRight = 0.0;
          // but we allow a tiny blend window if we want *continuous* fields even at the exact boundary
          const tt = smoothstep(0, bwFrac, u);
          wRight = tt * 0.18; // small early blend (keeps field continuous)
        }else if (u > 1 - bwFrac){
          // near right boundary => blend into right
          const tt = smoothstep(1 - bwFrac, 1, u);
          wRight = 0.82 + tt * 0.18; // finishes to 1
        }else{
          // interior => strongly left-ish for first half, right-ish for second half?
          // For "sector heat" look, we prefer each sector dominated by its center participant,
          // not a linear gradient across the whole wedge. So keep it mostly left until near right boundary.
          wRight = 0.08; // subtle drift inside sector
        }
        wRight = clamp01(wRight);

        const iL = left.i;
        const iR = right.i;

        const pctL = pctMap.get(participants[iL].id) || 0;
        const pctR = pctMap.get(participants[iR].id) || 0;

        // Normalize by maxPct for more differentiation
        const tL = clamp01(pctL / maxPct);
        const tR = clamp01(pctR / maxPct);

        // Blend dominance values (angular blending at boundaries)
        const t = (1 - wRight) * tL + wRight * tR;

        // Color + alpha from knobs (nonlinear + bold)
        const rgb = colorForDominance(t);
        const a = alphaForDominance(t);

        // Radial gradient: strongest near rim, fades inward.
        // Also slightly bias the gradient center toward the pill location for local ‚Äúpeak‚Äù.
        const pL = participants[iL];
        const pR = participants[iR];
        const cx = (1 - wRight) * pL.x + wRight * pR.x;
        const cy = (1 - wRight) * pL.y + wRight * pR.y;

        // gradient centered near rim point, but draw across whole disk
        const g = heatCtx.createRadialGradient(cx, cy, circleRadius*0.06, cx, cy, circleRadius*0.78);
        g.addColorStop(0.00, `rgba(${rgb.r},${rgb.g},${rgb.b},${Math.min(0.92, a*1.15)})`);
        g.addColorStop(0.22, `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`);
        g.addColorStop(0.72, `rgba(${rgb.r},${rgb.g},${rgb.b},${a*0.10})`);
        g.addColorStop(1.00, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);

        heatCtx.fillStyle = g;

        // Draw wedge slice
        heatCtx.beginPath();
        heatCtx.moveTo(centerX, centerY);
        heatCtx.arc(centerX, centerY, rOuter, theta, theta + dTheta, false);
        heatCtx.closePath();
        heatCtx.fill();
      }

      // Optional: a very faint overall radial wash to keep ‚Äúnear 0‚Äù baseline visible
      // (kept extremely subtle to avoid flattening contrast)
      heatCtx.save();
      const pal = getHeatPalette();
      const baseRgb = hexToRgb(pal.secondary);
      const wash = heatCtx.createRadialGradient(centerX, centerY, circleRadius*0.40, centerX, centerY, rOuter);
      wash.addColorStop(0, `rgba(${baseRgb.r},${baseRgb.g},${baseRgb.b},0)`);
      wash.addColorStop(1, `rgba(${baseRgb.r},${baseRgb.g},${baseRgb.b},0.035)`);
      heatCtx.fillStyle = wash;
      heatCtx.beginPath();
      heatCtx.arc(centerX, centerY, rOuter, 0, Math.PI*2);
      heatCtx.fill();
      heatCtx.restore();

      unclip(heatCtx);
    }

    // ---------- CLOSE overlays on background click ----------
    notesOverlay.addEventListener('click', (e) => { if (e.target === notesOverlay) closeNotesBox(); });
    colorSchemePopup.addEventListener('click', (e) => { if (e.target === colorSchemePopup) closeColorSchemePopup(); });
    customColorPopup.addEventListener('click', (e) => { if (e.target === customColorPopup) closeCustomColorPopup(); });
    confirmRestartPopup.addEventListener('click', (e) => { if (e.target === confirmRestartPopup) closeConfirmRestartPopup(); });
    editParticipantsPopup.addEventListener('click', (e) => { if (e.target === editParticipantsPopup) closeEditParticipantsPopup(); });

    // ---------- PUBLIC API for buttons ----------
    window.startDiscussion = startDiscussion;
    window.doneAddingParticipants = doneAddingParticipants;
    window.endDiscussion = endDiscussion;
    window.pauseTimer = pauseTimer;

    window.openNotesBoxById = openNotesBoxById;
    window.saveNotes = saveNotes;
    window.closeNotesBox = closeNotesBox;

    window.openColorSchemePopup = openColorSchemePopup;
    window.closeColorSchemePopup = closeColorSchemePopup;
    window.openCustomColorPopup = openCustomColorPopup;
    window.closeCustomColorPopup = closeCustomColorPopup;
    window.updatePrimaryColorCode = updatePrimaryColorCode;
    window.updateSecondaryColorCode = updateSecondaryColorCode;
    window.applyCustomColors = applyCustomColors;

    window.switchTab = switchTab;
    window.toggleDrawer = toggleDrawer;
    window.closeDrawer = closeDrawer;

    window.copyLog = copyLog;
    window.copyReport = copyReport;
    window.copyBoth = copyBoth;

    window.confirmRestartDiscussion = confirmRestartDiscussion;
    window.closeConfirmRestartPopup = closeConfirmRestartPopup;
    window.restartDiscussion = restartDiscussion;

    window.openEditParticipantsPopup = openEditParticipantsPopup;
    window.closeEditParticipantsPopup = closeEditParticipantsPopup;
    window.addNewParticipant = addNewParticipant;
    window.openReorderParticipants = openReorderParticipants;
    window.saveReorderedParticipants = saveReorderedParticipants;
    window.openRenameParticipants = openRenameParticipants;
    window.renameParticipant = renameParticipant;
    window.saveRenamedParticipants = saveRenamedParticipants;

    window.exportScreenshot = exportScreenshot;

    window.replayDiscussion = replayDiscussion;
    window.replayDiscussionTimed = replayDiscussionTimed;

    window.generateReport = generateReport;

    window.showHeatmap = showHeatmap;
    window.hideHeatmap = hideHeatmap;
  </script>
</body>
</html>
